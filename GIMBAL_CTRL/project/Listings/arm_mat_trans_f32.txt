; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\arm_mat_trans_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_trans_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\stm32LIB\inc -I..\stm32LIB\CMSIS\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\user\_Dsp\Include -I..\user\_Algorithms -I..\user\_Bsp -I..\user\_Device -I..\user\_Task -I..\system -I..\stm32LIB\CMSIS -I..\system -I..\FreeRTOS -I..\user -I.\RTE\_COD_Gimbal_Task -IC:\keil_v5_project\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=528 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM4 -D__FPU_PRESENT --omf_browse=.\objects\arm_mat_trans_f32.crf ..\stm32LIB\Device\arm_mat_trans_f32.c]
                          THUMB

                          AREA ||i.arm_mat_trans_f32||, CODE, READONLY, ALIGN=1

                  arm_mat_trans_f32 PROC
;;;68     
;;;69     arm_status arm_mat_trans_f32(
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;70       const arm_matrix_instance_f32 * pSrc,
;;;71       arm_matrix_instance_f32 * pDst)
;;;72     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;73       float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
000008  6861              LDR      r1,[r4,#4]
;;;74       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
00000a  f8d69004          LDR      r9,[r6,#4]
;;;75       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;76       uint16_t nRows = pSrc->numRows;                /* number of rows */
00000e  8823              LDRH     r3,[r4,#0]
;;;77       uint16_t nColumns = pSrc->numCols;             /* number of columns */
000010  8867              LDRH     r7,[r4,#2]
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       uint16_t blkCnt, i = 0u, row = nRows;          /* loop counters */
000012  f04f0c00          MOV      r12,#0
000016  4698              MOV      r8,r3
;;;84       arm_status status;                             /* status of matrix transpose  */
;;;85     
;;;86     
;;;87     #ifdef ARM_MATH_MATRIX_CHECK
;;;88     
;;;89     
;;;90       /* Check for matrix mismatch condition */
;;;91       if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;92       {
;;;93         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;94         status = ARM_MATH_SIZE_MISMATCH;
;;;95       }
;;;96       else
;;;97     #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;98     
;;;99       {
;;;100        /* Matrix transpose by exchanging the rows with columns */
;;;101        /* row loop     */
;;;102        do
000018  bf00              NOP      
                  |L1.26|
;;;103        {
;;;104          /* Loop Unrolling */
;;;105          blkCnt = nColumns >> 2;
00001a  10bd              ASRS     r5,r7,#2
;;;106    
;;;107          /* The pointer px is set to starting address of the column being processed */
;;;108          px = pOut + i;
00001c  eb09028c          ADD      r2,r9,r12,LSL #2
;;;109    
;;;110          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;111           ** a second loop below computes the remaining 1 to 3 samples. */
;;;112          while(blkCnt > 0u)        /* column loop */
000020  e01b              B        |L1.90|
                  |L1.34|
;;;113          {
;;;114            /* Read and store the input element in the destination */
;;;115            *px = *pIn++;
000022  ecb10a01          VLDM     r1!,{s0}
000026  ed820a00          VSTR     s0,[r2,#0]
;;;116    
;;;117            /* Update the pointer px to point to the next row of the transposed matrix */
;;;118            px += nRows;
00002a  eb020283          ADD      r2,r2,r3,LSL #2
;;;119    
;;;120            /* Read and store the input element in the destination */
;;;121            *px = *pIn++;
00002e  ecb10a01          VLDM     r1!,{s0}
000032  ed820a00          VSTR     s0,[r2,#0]
;;;122    
;;;123            /* Update the pointer px to point to the next row of the transposed matrix */
;;;124            px += nRows;
000036  eb020283          ADD      r2,r2,r3,LSL #2
;;;125    
;;;126            /* Read and store the input element in the destination */
;;;127            *px = *pIn++;
00003a  ecb10a01          VLDM     r1!,{s0}
00003e  ed820a00          VSTR     s0,[r2,#0]
;;;128    
;;;129            /* Update the pointer px to point to the next row of the transposed matrix */
;;;130            px += nRows;
000042  eb020283          ADD      r2,r2,r3,LSL #2
;;;131    
;;;132            /* Read and store the input element in the destination */
;;;133            *px = *pIn++;
000046  ecb10a01          VLDM     r1!,{s0}
00004a  ed820a00          VSTR     s0,[r2,#0]
;;;134    
;;;135            /* Update the pointer px to point to the next row of the transposed matrix */
;;;136            px += nRows;
00004e  eb020283          ADD      r2,r2,r3,LSL #2
;;;137    
;;;138            /* Decrement the column loop counter */
;;;139            blkCnt--;
000052  f1a50a01          SUB      r10,r5,#1
000056  fa1ff58a          UXTH     r5,r10
                  |L1.90|
00005a  2d00              CMP      r5,#0                 ;112
00005c  d1e1              BNE      |L1.34|
;;;140          }
;;;141    
;;;142          /* Perform matrix transpose for last 3 samples here. */
;;;143          blkCnt = nColumns % 0x4u;
00005e  f0070503          AND      r5,r7,#3
;;;144    
;;;145          while(blkCnt > 0u)
000062  e009              B        |L1.120|
                  |L1.100|
;;;146          {
;;;147            /* Read and store the input element in the destination */
;;;148            *px = *pIn++;
000064  ecb10a01          VLDM     r1!,{s0}
000068  ed820a00          VSTR     s0,[r2,#0]
;;;149    
;;;150            /* Update the pointer px to point to the next row of the transposed matrix */
;;;151            px += nRows;
00006c  eb020283          ADD      r2,r2,r3,LSL #2
;;;152    
;;;153            /* Decrement the column loop counter */
;;;154            blkCnt--;
000070  f1a50a01          SUB      r10,r5,#1
000074  fa1ff58a          UXTH     r5,r10
                  |L1.120|
000078  2d00              CMP      r5,#0                 ;145
00007a  d1f3              BNE      |L1.100|
;;;155          }
;;;156    
;;;157    #else
;;;158    
;;;159      /* Run the below code for Cortex-M0 */
;;;160    
;;;161      uint16_t col, i = 0u, row = nRows;             /* loop counters */
;;;162      arm_status status;                             /* status of matrix transpose  */
;;;163    
;;;164    
;;;165    #ifdef ARM_MATH_MATRIX_CHECK
;;;166    
;;;167      /* Check for matrix mismatch condition */
;;;168      if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;169      {
;;;170        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;171        status = ARM_MATH_SIZE_MISMATCH;
;;;172      }
;;;173      else
;;;174    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;175    
;;;176      {
;;;177        /* Matrix transpose by exchanging the rows with columns */
;;;178        /* row loop     */
;;;179        do
;;;180        {
;;;181          /* The pointer px is set to starting address of the column being processed */
;;;182          px = pOut + i;
;;;183    
;;;184          /* Initialize column loop counter */
;;;185          col = nColumns;
;;;186    
;;;187          while(col > 0u)
;;;188          {
;;;189            /* Read and store the input element in the destination */
;;;190            *px = *pIn++;
;;;191    
;;;192            /* Update the pointer px to point to the next row of the transposed matrix */
;;;193            px += nRows;
;;;194    
;;;195            /* Decrement the column loop counter */
;;;196            col--;
;;;197          }
;;;198    
;;;199    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;200    
;;;201          i++;
00007c  f10c0a01          ADD      r10,r12,#1
000080  fa1ffc8a          UXTH     r12,r10
;;;202    
;;;203          /* Decrement the row loop counter */
;;;204          row--;
000084  f1a80a01          SUB      r10,r8,#1
000088  fa1ff88a          UXTH     r8,r10
;;;205    
;;;206        } while(row > 0u);          /* row loop end  */
00008c  f1b80f00          CMP      r8,#0
000090  d1c3              BNE      |L1.26|
;;;207    
;;;208        /* Set status as ARM_MATH_SUCCESS */
;;;209        status = ARM_MATH_SUCCESS;
000092  2000              MOVS     r0,#0
;;;210      }
;;;211    
;;;212      /* Return to application */
;;;213      return (status);
;;;214    }
000094  e8bd87f0          POP      {r4-r10,pc}
;;;215    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\stm32LIB\\Device\\arm_mat_trans_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____REV16|
#line 388 "..\\stm32LIB\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____REVSH|
#line 402
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____RRX|
#line 587
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
