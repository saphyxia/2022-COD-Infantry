; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\arm_mat_cmplx_mult_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\stm32LIB\inc -I..\stm32LIB\CMSIS\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\user\_Dsp\Include -I..\user\_Algorithms -I..\user\_Bsp -I..\user\_Device -I..\user\_Task -I..\system -I..\stm32LIB\CMSIS -I..\system -I..\FreeRTOS -I..\user -I.\RTE\_COD_Gimbal_Task -IC:\keil_v5_project\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=528 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM4 -D__FPU_PRESENT --omf_browse=.\objects\arm_mat_cmplx_mult_f32.crf ..\stm32LIB\Device\arm_mat_cmplx_mult_f32.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_cmplx_mult_f32 PROC
;;;72     
;;;73     arm_status arm_mat_cmplx_mult_f32(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;74       const arm_matrix_instance_f32 * pSrcA,
;;;75       const arm_matrix_instance_f32 * pSrcB,
;;;76       arm_matrix_instance_f32 * pDst)
;;;77     {
000004  b084              SUB      sp,sp,#0x10
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;78       float32_t *pIn1 = pSrcA->pData;                /* input data matrix pointer A */
00000a  6861              LDR      r1,[r4,#4]
;;;79       float32_t *pIn2 = pSrcB->pData;                /* input data matrix pointer B */
00000c  686a              LDR      r2,[r5,#4]
;;;80       float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A  */
00000e  f8d48004          LDR      r8,[r4,#4]
;;;81       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
000012  9806              LDR      r0,[sp,#0x18]
000014  6840              LDR      r0,[r0,#4]
000016  9003              STR      r0,[sp,#0xc]
;;;82       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;83       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
000018  8820              LDRH     r0,[r4,#0]
00001a  9002              STR      r0,[sp,#8]
;;;84       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
00001c  886b              LDRH     r3,[r5,#2]
;;;85       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
00001e  f8b4c002          LDRH     r12,[r4,#2]
;;;86       float32_t sumReal1, sumImag1;                  /* accumulator */
;;;87       float32_t a0, b0, c0, d0;
;;;88       float32_t a1, b1, c1, d1;
;;;89       float32_t sumReal2, sumImag2;                  /* accumulator */
;;;90     
;;;91     
;;;92       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;93     
;;;94       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000022  f04f0a00          MOV      r10,#0
000026  9802              LDR      r0,[sp,#8]
000028  9001              STR      r0,[sp,#4]
;;;95       arm_status status;                             /* status of matrix multiplication */
;;;96     
;;;97     #ifdef ARM_MATH_MATRIX_CHECK
;;;98     
;;;99     
;;;100      /* Check for matrix mismatch condition */
;;;101      if((pSrcA->numCols != pSrcB->numRows) ||
;;;102         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;103      {
;;;104    
;;;105        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;106        status = ARM_MATH_SIZE_MISMATCH;
;;;107      }
;;;108      else
;;;109    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;110    
;;;111      {
;;;112        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;113        /* row loop */
;;;114        do
00002a  bf00              NOP      
                  |L1.44|
;;;115        {
;;;116          /* Output pointer is set to starting address of the row being processed */
;;;117          px = pOut + 2 * i;
00002c  9803              LDR      r0,[sp,#0xc]
00002e  eb0007ca          ADD      r7,r0,r10,LSL #3
;;;118    
;;;119          /* For every row wise process, the column loop counter is to be initiated */
;;;120          col = numColsB;
000032  4699              MOV      r9,r3
;;;121    
;;;122          /* For every row wise process, the pIn2 pointer is set      
;;;123           ** to the starting address of the pSrcB data */
;;;124          pIn2 = pSrcB->pData;
000034  686a              LDR      r2,[r5,#4]
;;;125    
;;;126          j = 0u;
000036  f04f0b00          MOV      r11,#0
;;;127    
;;;128          /* column loop */
;;;129          do
00003a  bf00              NOP      
                  |L1.60|
;;;130          {
;;;131            /* Set the variable sum, that acts as accumulator, to zero */
;;;132            sumReal1 = 0.0f;
00003c  ed9f6a92          VLDR     s12,|L1.648|
000040  eeb00a46          VMOV.F32 s0,s12
;;;133            sumImag1 = 0.0f;
000044  ed9f6a90          VLDR     s12,|L1.648|
000048  eef00a46          VMOV.F32 s1,s12
;;;134    
;;;135            sumReal2 = 0.0f;
00004c  ed9f6a8e          VLDR     s12,|L1.648|
000050  eeb03a46          VMOV.F32 s6,s12
;;;136            sumImag2 = 0.0f;
000054  ed9f6a8c          VLDR     s12,|L1.648|
000058  eef03a46          VMOV.F32 s7,s12
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;139            pIn1 = pInA;
00005c  4641              MOV      r1,r8
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2;
00005e  ea4f06ac          ASR      r6,r12,#2
;;;143    
;;;144            /* matrix multiplication        */
;;;145            while(colCnt > 0u)
000062  e0ad              B        |L1.448|
                  |L1.100|
;;;146            {
;;;147    
;;;148              /* Reading real part of complex matrix A */
;;;149              a0 = *pIn1;
000064  ed916a00          VLDR     s12,[r1,#0]
000068  eeb04a46          VMOV.F32 s8,s12
;;;150    
;;;151              /* Reading real part of complex matrix B */
;;;152              c0 = *pIn2;
00006c  ed926a00          VLDR     s12,[r2,#0]
000070  eeb05a46          VMOV.F32 s10,s12
;;;153    
;;;154              /* Reading imaginary part of complex matrix A */
;;;155              b0 = *(pIn1 + 1u);
000074  ed916a01          VLDR     s12,[r1,#4]
000078  eef04a46          VMOV.F32 s9,s12
;;;156    
;;;157              /* Reading imaginary part of complex matrix B */
;;;158              d0 = *(pIn2 + 1u);
00007c  ed926a01          VLDR     s12,[r2,#4]
000080  eef05a46          VMOV.F32 s11,s12
;;;159    
;;;160              sumReal1 += a0 * c0;
000084  eeb06a40          VMOV.F32 s12,s0
000088  ee046a05          VMLA.F32 s12,s8,s10
00008c  eeb00a46          VMOV.F32 s0,s12
;;;161              sumImag1 += b0 * c0;
000090  eeb06a60          VMOV.F32 s12,s1
000094  ee046a85          VMLA.F32 s12,s9,s10
000098  eef00a46          VMOV.F32 s1,s12
;;;162    
;;;163              pIn1 += 2u;
00009c  3108              ADDS     r1,r1,#8
;;;164              pIn2 += 2 * numColsB;
00009e  eb0202c3          ADD      r2,r2,r3,LSL #3
;;;165    
;;;166              sumReal2 -= b0 * d0;
0000a2  eeb06a43          VMOV.F32 s12,s6
0000a6  ee046ae5          VMLS.F32 s12,s9,s11
0000aa  eeb03a46          VMOV.F32 s6,s12
;;;167              sumImag2 += a0 * d0;
0000ae  eeb06a63          VMOV.F32 s12,s7
0000b2  ee046a25          VMLA.F32 s12,s8,s11
0000b6  eef03a46          VMOV.F32 s7,s12
;;;168    
;;;169              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;170    
;;;171              a1 = *pIn1;
0000ba  ed916a00          VLDR     s12,[r1,#0]
0000be  eeb01a46          VMOV.F32 s2,s12
;;;172              c1 = *pIn2;
0000c2  ed926a00          VLDR     s12,[r2,#0]
0000c6  eeb02a46          VMOV.F32 s4,s12
;;;173    
;;;174              b1 = *(pIn1 + 1u);
0000ca  ed916a01          VLDR     s12,[r1,#4]
0000ce  eef01a46          VMOV.F32 s3,s12
;;;175              d1 = *(pIn2 + 1u);
0000d2  ed926a01          VLDR     s12,[r2,#4]
0000d6  eef02a46          VMOV.F32 s5,s12
;;;176    
;;;177              sumReal1 += a1 * c1;
0000da  eeb06a40          VMOV.F32 s12,s0
0000de  ee016a02          VMLA.F32 s12,s2,s4
0000e2  eeb00a46          VMOV.F32 s0,s12
;;;178              sumImag1 += b1 * c1;
0000e6  eeb06a60          VMOV.F32 s12,s1
0000ea  ee016a82          VMLA.F32 s12,s3,s4
0000ee  eef00a46          VMOV.F32 s1,s12
;;;179    
;;;180              pIn1 += 2u;
0000f2  3108              ADDS     r1,r1,#8
;;;181              pIn2 += 2 * numColsB;
0000f4  eb0202c3          ADD      r2,r2,r3,LSL #3
;;;182    
;;;183              sumReal2 -= b1 * d1;
0000f8  eeb06a43          VMOV.F32 s12,s6
0000fc  ee016ae2          VMLS.F32 s12,s3,s5
000100  eeb03a46          VMOV.F32 s6,s12
;;;184              sumImag2 += a1 * d1;
000104  eeb06a63          VMOV.F32 s12,s7
000108  ee016a22          VMLA.F32 s12,s2,s5
00010c  eef03a46          VMOV.F32 s7,s12
;;;185    
;;;186              a0 = *pIn1;
000110  ed916a00          VLDR     s12,[r1,#0]
000114  eeb04a46          VMOV.F32 s8,s12
;;;187              c0 = *pIn2;
000118  ed926a00          VLDR     s12,[r2,#0]
00011c  eeb05a46          VMOV.F32 s10,s12
;;;188    
;;;189              b0 = *(pIn1 + 1u);
000120  ed916a01          VLDR     s12,[r1,#4]
000124  eef04a46          VMOV.F32 s9,s12
;;;190              d0 = *(pIn2 + 1u);
000128  ed926a01          VLDR     s12,[r2,#4]
00012c  eef05a46          VMOV.F32 s11,s12
;;;191    
;;;192              sumReal1 += a0 * c0;
000130  eeb06a40          VMOV.F32 s12,s0
000134  ee046a05          VMLA.F32 s12,s8,s10
000138  eeb00a46          VMOV.F32 s0,s12
;;;193              sumImag1 += b0 * c0;
00013c  eeb06a60          VMOV.F32 s12,s1
000140  ee046a85          VMLA.F32 s12,s9,s10
000144  eef00a46          VMOV.F32 s1,s12
;;;194    
;;;195              pIn1 += 2u;
000148  3108              ADDS     r1,r1,#8
;;;196              pIn2 += 2 * numColsB;
00014a  eb0202c3          ADD      r2,r2,r3,LSL #3
;;;197    
;;;198              sumReal2 -= b0 * d0;
00014e  eeb06a43          VMOV.F32 s12,s6
000152  ee046ae5          VMLS.F32 s12,s9,s11
000156  eeb03a46          VMOV.F32 s6,s12
;;;199              sumImag2 += a0 * d0;
00015a  eeb06a63          VMOV.F32 s12,s7
00015e  ee046a25          VMLA.F32 s12,s8,s11
000162  eef03a46          VMOV.F32 s7,s12
;;;200    
;;;201              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;202    
;;;203              a1 = *pIn1;
000166  ed916a00          VLDR     s12,[r1,#0]
00016a  eeb01a46          VMOV.F32 s2,s12
;;;204              c1 = *pIn2;
00016e  ed926a00          VLDR     s12,[r2,#0]
000172  eeb02a46          VMOV.F32 s4,s12
;;;205    
;;;206              b1 = *(pIn1 + 1u);
000176  ed916a01          VLDR     s12,[r1,#4]
00017a  eef01a46          VMOV.F32 s3,s12
;;;207              d1 = *(pIn2 + 1u);
00017e  ed926a01          VLDR     s12,[r2,#4]
000182  eef02a46          VMOV.F32 s5,s12
;;;208    
;;;209              sumReal1 += a1 * c1;
000186  eeb06a40          VMOV.F32 s12,s0
00018a  ee016a02          VMLA.F32 s12,s2,s4
00018e  eeb00a46          VMOV.F32 s0,s12
;;;210              sumImag1 += b1 * c1;
000192  eeb06a60          VMOV.F32 s12,s1
000196  ee016a82          VMLA.F32 s12,s3,s4
00019a  eef00a46          VMOV.F32 s1,s12
;;;211    
;;;212              pIn1 += 2u;
00019e  3108              ADDS     r1,r1,#8
;;;213              pIn2 += 2 * numColsB;
0001a0  eb0202c3          ADD      r2,r2,r3,LSL #3
;;;214    
;;;215              sumReal2 -= b1 * d1;
0001a4  eeb06a43          VMOV.F32 s12,s6
0001a8  ee016ae2          VMLS.F32 s12,s3,s5
0001ac  eeb03a46          VMOV.F32 s6,s12
;;;216              sumImag2 += a1 * d1;
0001b0  eeb06a63          VMOV.F32 s12,s7
0001b4  ee016a22          VMLA.F32 s12,s2,s5
0001b8  eef03a46          VMOV.F32 s7,s12
;;;217    
;;;218              /* Decrement the loop count */
;;;219              colCnt--;
0001bc  1e70              SUBS     r0,r6,#1
0001be  b286              UXTH     r6,r0
                  |L1.448|
0001c0  2e00              CMP      r6,#0                 ;145
0001c2  f47faf4f          BNE      |L1.100|
;;;220            }
;;;221    
;;;222            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.      
;;;223             ** No loop unrolling is used. */
;;;224            colCnt = numColsA % 0x4u;
0001c6  f00c0603          AND      r6,r12,#3
;;;225    
;;;226            while(colCnt > 0u)
0001ca  e02c              B        |L1.550|
                  |L1.460|
;;;227            {
;;;228              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;229              a1 = *pIn1;
0001cc  ed916a00          VLDR     s12,[r1,#0]
0001d0  eeb01a46          VMOV.F32 s2,s12
;;;230              c1 = *pIn2;
0001d4  ed926a00          VLDR     s12,[r2,#0]
0001d8  eeb02a46          VMOV.F32 s4,s12
;;;231    
;;;232              b1 = *(pIn1 + 1u);
0001dc  ed916a01          VLDR     s12,[r1,#4]
0001e0  eef01a46          VMOV.F32 s3,s12
;;;233              d1 = *(pIn2 + 1u);
0001e4  ed926a01          VLDR     s12,[r2,#4]
0001e8  eef02a46          VMOV.F32 s5,s12
;;;234    
;;;235              sumReal1 += a1 * c1;
0001ec  eeb06a40          VMOV.F32 s12,s0
0001f0  ee016a02          VMLA.F32 s12,s2,s4
0001f4  eeb00a46          VMOV.F32 s0,s12
;;;236              sumImag1 += b1 * c1;
0001f8  eeb06a60          VMOV.F32 s12,s1
0001fc  ee016a82          VMLA.F32 s12,s3,s4
000200  eef00a46          VMOV.F32 s1,s12
;;;237    
;;;238              pIn1 += 2u;
000204  3108              ADDS     r1,r1,#8
;;;239              pIn2 += 2 * numColsB;
000206  eb0202c3          ADD      r2,r2,r3,LSL #3
;;;240    
;;;241              sumReal2 -= b1 * d1;
00020a  eeb06a43          VMOV.F32 s12,s6
00020e  ee016ae2          VMLS.F32 s12,s3,s5
000212  eeb03a46          VMOV.F32 s6,s12
;;;242              sumImag2 += a1 * d1;
000216  eeb06a63          VMOV.F32 s12,s7
00021a  ee016a22          VMLA.F32 s12,s2,s5
00021e  eef03a46          VMOV.F32 s7,s12
;;;243    
;;;244              /* Decrement the loop counter */
;;;245              colCnt--;
000222  1e70              SUBS     r0,r6,#1
000224  b286              UXTH     r6,r0
                  |L1.550|
000226  2e00              CMP      r6,#0                 ;226
000228  d1d0              BNE      |L1.460|
;;;246            }
;;;247    
;;;248            sumReal1 += sumReal2;
00022a  ee306a03          VADD.F32 s12,s0,s6
00022e  eeb00a46          VMOV.F32 s0,s12
;;;249            sumImag1 += sumImag2;
000232  ee306aa3          VADD.F32 s12,s1,s7
000236  eef00a46          VMOV.F32 s1,s12
;;;250    
;;;251            /* Store the result in the destination buffer */
;;;252            *px++ = sumReal1;
00023a  eca70a01          VSTM     r7!,{s0}
;;;253            *px++ = sumImag1;
00023e  ece70a01          VSTM     r7!,{s1}
;;;254    
;;;255            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;256            j++;
000242  f10b0001          ADD      r0,r11,#1
000246  fa1ffb80          UXTH     r11,r0
;;;257            pIn2 = pSrcB->pData + 2u * j;
00024a  6868              LDR      r0,[r5,#4]
00024c  eb0002cb          ADD      r2,r0,r11,LSL #3
;;;258    
;;;259            /* Decrement the column loop counter */
;;;260            col--;
000250  f1a90001          SUB      r0,r9,#1
000254  fa1ff980          UXTH     r9,r0
;;;261    
;;;262          } while(col > 0u);
000258  f1b90f00          CMP      r9,#0
00025c  f47faeee          BNE      |L1.60|
;;;263    
;;;264          /* Update the pointer pInA to point to the  starting address of the next row */
;;;265          i = i + numColsB;
000260  eb0a0003          ADD      r0,r10,r3
000264  fa1ffa80          UXTH     r10,r0
;;;266          pInA = pInA + 2 * numColsA;
000268  eb0808cc          ADD      r8,r8,r12,LSL #3
;;;267    
;;;268          /* Decrement the row loop counter */
;;;269          row--;
00026c  9801              LDR      r0,[sp,#4]
00026e  1e40              SUBS     r0,r0,#1
000270  b280              UXTH     r0,r0
000272  9001              STR      r0,[sp,#4]
;;;270    
;;;271        } while(row > 0u);
000274  9801              LDR      r0,[sp,#4]
000276  2800              CMP      r0,#0
000278  f47faed8          BNE      |L1.44|
;;;272    
;;;273        /* Set status as ARM_MATH_SUCCESS */
;;;274        status = ARM_MATH_SUCCESS;
00027c  9000              STR      r0,[sp,#0]
;;;275      }
;;;276    
;;;277      /* Return to application */
;;;278      return (status);
00027e  9800              LDR      r0,[sp,#0]
;;;279    }
000280  b007              ADD      sp,sp,#0x1c
000282  e8bd8ff0          POP      {r4-r11,pc}
;;;280    
                          ENDP

000286  0000              DCW      0x0000
                  |L1.648|
000288  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\stm32LIB\\Device\\arm_mat_cmplx_mult_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REV16|
#line 388 "..\\stm32LIB\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REVSH|
#line 402
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____RRX|
#line 587
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
