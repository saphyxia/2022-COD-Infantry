; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\arm_mat_inverse_f64.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_inverse_f64.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\stm32LIB\inc -I..\stm32LIB\CMSIS\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\user\_Dsp\Include -I..\user\_Algorithms -I..\user\_Bsp -I..\user\_Device -I..\user\_Task -I..\system -I..\stm32LIB\CMSIS -I..\system -I..\FreeRTOS -I..\user -I.\RTE\_COD_Gimbal_Task -IC:\keil_v5_project\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=528 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM4 -D__FPU_PRESENT --omf_browse=.\objects\arm_mat_inverse_f64.crf ..\stm32LIB\Device\arm_mat_inverse_f64.c]
                          THUMB

                          AREA ||i.arm_mat_inverse_f64||, CODE, READONLY, ALIGN=2

                  arm_mat_inverse_f64 PROC
;;;72     
;;;73     arm_status arm_mat_inverse_f64(
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;74       const arm_matrix_instance_f64 * pSrc,
;;;75       arm_matrix_instance_f64 * pDst)
;;;76     {
000004  ed2d8b06          VPUSH    {d8-d10}
000008  b08d              SUB      sp,sp,#0x34
;;;77       float64_t *pIn = pSrc->pData;                  /* input data matrix pointer */
00000a  9813              LDR      r0,[sp,#0x4c]
00000c  f8d0a004          LDR      r10,[r0,#4]
;;;78       float64_t *pOut = pDst->pData;                 /* output data matrix pointer */
000010  9814              LDR      r0,[sp,#0x50]
000012  6840              LDR      r0,[r0,#4]
000014  900c              STR      r0,[sp,#0x30]
;;;79       float64_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
;;;80       float64_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
;;;81       float64_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data matrix pointer */
;;;82       uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
000016  9813              LDR      r0,[sp,#0x4c]
000018  f8b0b000          LDRH     r11,[r0,#0]
;;;83       uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
00001c  9813              LDR      r0,[sp,#0x4c]
00001e  8844              LDRH     r4,[r0,#2]
;;;84     
;;;85     #if defined (ARM_MATH_DSP)
;;;86       float64_t maxC;                                /* maximum value in the column */
;;;87     
;;;88       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;89     
;;;90       float64_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
;;;91       uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
;;;92       arm_status status;                             /* status of matrix inverse */
;;;93     
;;;94     #ifdef ARM_MATH_MATRIX_CHECK
;;;95     
;;;96     
;;;97       /* Check for matrix mismatch condition */
;;;98       if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;99          || (pSrc->numRows != pDst->numRows))
;;;100      {
;;;101        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;102        status = ARM_MATH_SIZE_MISMATCH;
;;;103      }
;;;104      else
;;;105    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;106    
;;;107      {
;;;108    
;;;109        /*--------------------------------------------------------------------------------------------------------------
;;;110    	 * Matrix Inverse can be solved using elementary row operations.
;;;111    	 *
;;;112    	 *	Gauss-Jordan Method:
;;;113    	 *
;;;114    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an
;;;115    	 *        augmented matrix as follows:
;;;116    	 *				        _ 	      	       _         _	       _
;;;117    	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |
;;;118    	 *					   |           |        |   =   |           |
;;;119    	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|
;;;120    	 *
;;;121    	 *		2. In our implementation, pDst Matrix is used as identity matrix.
;;;122    	 *
;;;123    	 *		3. Begin with the first row. Let i = 1.
;;;124    	 *
;;;125    	 *	    4. Check to see if the pivot for column i is the greatest of the column.
;;;126    	 *		   The pivot is the element of the main diagonal that is on the current row.
;;;127    	 *		   For instance, if working with row i, then the pivot element is aii.
;;;128    	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
;;;129    	 *		   below it that does contain the most significant value in column i. If the most
;;;130    	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
;;;131    	 *		   The most significant value of the column is the absolute maximum.
;;;132    	 *
;;;133    	 *	    5. Divide every element of row i by the pivot.
;;;134    	 *
;;;135    	 *	    6. For every row below and  row i, replace that row with the sum of that row and
;;;136    	 *		   a multiple of row i so that each new element in column i below row i is zero.
;;;137    	 *
;;;138    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
;;;139    	 *		   for every element below and above the main diagonal.
;;;140    	 *
;;;141    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).
;;;142    	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).
;;;143    	 *----------------------------------------------------------------------------------------------------------------*/
;;;144    
;;;145        /* Working pointer for destination matrix */
;;;146        pOutT1 = pOut;
;;;147    
;;;148        /* Loop over the number of rows */
;;;149        rowCnt = numRows;
;;;150    
;;;151        /* Making the destination matrix as identity matrix */
;;;152        while (rowCnt > 0U)
;;;153        {
;;;154          /* Writing all zeroes in lower triangle of the destination matrix */
;;;155          j = numRows - rowCnt;
;;;156          while (j > 0U)
;;;157          {
;;;158            *pOutT1++ = 0.0f;
;;;159            j--;
;;;160          }
;;;161    
;;;162          /* Writing all ones in the diagonal of the destination matrix */
;;;163          *pOutT1++ = 1.0f;
;;;164    
;;;165          /* Writing all zeroes in upper triangle of the destination matrix */
;;;166          j = rowCnt - 1U;
;;;167          while (j > 0U)
;;;168          {
;;;169            *pOutT1++ = 0.0f;
;;;170            j--;
;;;171          }
;;;172    
;;;173          /* Decrement the loop counter */
;;;174          rowCnt--;
;;;175        }
;;;176    
;;;177        /* Loop over the number of columns of the input matrix.
;;;178           All the elements in each column are processed by the row operations */
;;;179        loopCnt = numCols;
;;;180    
;;;181        /* Index modifier to navigate through the columns */
;;;182        l = 0U;
;;;183    
;;;184        while (loopCnt > 0U)
;;;185        {
;;;186          /* Check if the pivot element is zero..
;;;187           * If it is zero then interchange the row with non zero row below.
;;;188           * If there is no non zero element to replace in the rows below,
;;;189           * then the matrix is Singular. */
;;;190    
;;;191          /* Working pointer for the input matrix that points
;;;192           * to the pivot element of the particular row  */
;;;193          pInT1 = pIn + (l * numCols);
;;;194    
;;;195          /* Working pointer for the destination matrix that points
;;;196           * to the pivot element of the particular row  */
;;;197          pOutT1 = pOut + (l * numCols);
;;;198    
;;;199          /* Temporary variable to hold the pivot value */
;;;200          in = *pInT1;
;;;201    
;;;202          /* Grab the most significant value from column l */
;;;203          maxC = 0;
;;;204          for (i = l; i < numRows; i++)
;;;205          {
;;;206            maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
;;;207            pInT1 += numCols;
;;;208          }
;;;209    
;;;210          /* Update the status if the matrix is singular */
;;;211          if (maxC == 0.0f)
;;;212          {
;;;213            return ARM_MATH_SINGULAR;
;;;214          }
;;;215    
;;;216          /* Restore pInT1  */
;;;217          pInT1 = pIn;
;;;218    
;;;219          /* Destination pointer modifier */
;;;220          k = 1U;
;;;221    
;;;222          /* Check if the pivot element is the most significant of the column */
;;;223          if ( (in > 0.0f ? in : -in) != maxC)
;;;224          {
;;;225            /* Loop over the number rows present below */
;;;226            i = numRows - (l + 1U);
;;;227    
;;;228            while (i > 0U)
;;;229            {
;;;230              /* Update the input and destination pointers */
;;;231              pInT2 = pInT1 + (numCols * l);
;;;232              pOutT2 = pOutT1 + (numCols * k);
;;;233    
;;;234              /* Look for the most significant element to
;;;235               * replace in the rows below */
;;;236              if ((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
;;;237              {
;;;238                /* Loop over number of columns
;;;239                 * to the right of the pilot element */
;;;240                j = numCols - l;
;;;241    
;;;242                while (j > 0U)
;;;243                {
;;;244                  /* Exchange the row elements of the input matrix */
;;;245                  Xchg = *pInT2;
;;;246                  *pInT2++ = *pInT1;
;;;247                  *pInT1++ = Xchg;
;;;248    
;;;249                  /* Decrement the loop counter */
;;;250                  j--;
;;;251                }
;;;252    
;;;253                /* Loop over number of columns of the destination matrix */
;;;254                j = numCols;
;;;255    
;;;256                while (j > 0U)
;;;257                {
;;;258                  /* Exchange the row elements of the destination matrix */
;;;259                  Xchg = *pOutT2;
;;;260                  *pOutT2++ = *pOutT1;
;;;261                  *pOutT1++ = Xchg;
;;;262    
;;;263                  /* Decrement the loop counter */
;;;264                  j--;
;;;265                }
;;;266    
;;;267                /* Flag to indicate whether exchange is done or not */
;;;268                flag = 1U;
;;;269    
;;;270                /* Break after exchange is done */
;;;271                break;
;;;272              }
;;;273    
;;;274              /* Update the destination pointer modifier */
;;;275              k++;
;;;276    
;;;277              /* Decrement the loop counter */
;;;278              i--;
;;;279            }
;;;280          }
;;;281    
;;;282          /* Update the status if the matrix is singular */
;;;283          if ((flag != 1U) && (in == 0.0f))
;;;284          {
;;;285            return ARM_MATH_SINGULAR;
;;;286          }
;;;287    
;;;288          /* Points to the pivot row of input and destination matrices */
;;;289          pPivotRowIn = pIn + (l * numCols);
;;;290          pPivotRowDst = pOut + (l * numCols);
;;;291    
;;;292          /* Temporary pointers to the pivot row pointers */
;;;293          pInT1 = pPivotRowIn;
;;;294          pInT2 = pPivotRowDst;
;;;295    
;;;296          /* Pivot element of the row */
;;;297          in = *pPivotRowIn;
;;;298    
;;;299          /* Loop over number of columns
;;;300           * to the right of the pilot element */
;;;301          j = (numCols - l);
;;;302    
;;;303          while (j > 0U)
;;;304          {
;;;305            /* Divide each element of the row of the input matrix
;;;306             * by the pivot element */
;;;307            in1 = *pInT1;
;;;308            *pInT1++ = in1 / in;
;;;309    
;;;310            /* Decrement the loop counter */
;;;311            j--;
;;;312          }
;;;313    
;;;314          /* Loop over number of columns of the destination matrix */
;;;315          j = numCols;
;;;316    
;;;317          while (j > 0U)
;;;318          {
;;;319            /* Divide each element of the row of the destination matrix
;;;320             * by the pivot element */
;;;321            in1 = *pInT2;
;;;322            *pInT2++ = in1 / in;
;;;323    
;;;324            /* Decrement the loop counter */
;;;325            j--;
;;;326          }
;;;327    
;;;328          /* Replace the rows with the sum of that row and a multiple of row i
;;;329           * so that each new element in column i above row i is zero.*/
;;;330    
;;;331          /* Temporary pointers for input and destination matrices */
;;;332          pInT1 = pIn;
;;;333          pInT2 = pOut;
;;;334    
;;;335          /* index used to check for pivot element */
;;;336          i = 0U;
;;;337    
;;;338          /* Loop over number of rows */
;;;339          /*  to be replaced by the sum of that row and a multiple of row i */
;;;340          k = numRows;
;;;341    
;;;342          while (k > 0U)
;;;343          {
;;;344            /* Check for the pivot element */
;;;345            if (i == l)
;;;346            {
;;;347              /* If the processing element is the pivot element,
;;;348                 only the columns to the right are to be processed */
;;;349              pInT1 += numCols - l;
;;;350    
;;;351              pInT2 += numCols;
;;;352            }
;;;353            else
;;;354            {
;;;355              /* Element of the reference row */
;;;356              in = *pInT1;
;;;357    
;;;358              /* Working pointers for input and destination pivot rows */
;;;359              pPRT_in = pPivotRowIn;
;;;360              pPRT_pDst = pPivotRowDst;
;;;361    
;;;362              /* Loop over the number of columns to the right of the pivot element,
;;;363                 to replace the elements in the input matrix */
;;;364              j = (numCols - l);
;;;365    
;;;366              while (j > 0U)
;;;367              {
;;;368                /* Replace the element by the sum of that row
;;;369                   and a multiple of the reference row  */
;;;370                in1 = *pInT1;
;;;371                *pInT1++ = in1 - (in * *pPRT_in++);
;;;372    
;;;373                /* Decrement the loop counter */
;;;374                j--;
;;;375              }
;;;376    
;;;377              /* Loop over the number of columns to
;;;378                 replace the elements in the destination matrix */
;;;379              j = numCols;
;;;380    
;;;381              while (j > 0U)
;;;382              {
;;;383                /* Replace the element by the sum of that row
;;;384                   and a multiple of the reference row  */
;;;385                in1 = *pInT2;
;;;386                *pInT2++ = in1 - (in * *pPRT_pDst++);
;;;387    
;;;388                /* Decrement the loop counter */
;;;389                j--;
;;;390              }
;;;391    
;;;392            }
;;;393    
;;;394            /* Increment the temporary input pointer */
;;;395            pInT1 = pInT1 + l;
;;;396    
;;;397            /* Decrement the loop counter */
;;;398            k--;
;;;399    
;;;400            /* Increment the pivot index */
;;;401            i++;
;;;402          }
;;;403    
;;;404          /* Increment the input pointer */
;;;405          pIn++;
;;;406    
;;;407          /* Decrement the loop counter */
;;;408          loopCnt--;
;;;409    
;;;410          /* Increment the index modifier */
;;;411          l++;
;;;412        }
;;;413    
;;;414    
;;;415    #else
;;;416    
;;;417      /* Run the below code for Cortex-M0 */
;;;418    
;;;419      float64_t Xchg, in = 0.0f;                     /* Temporary input values  */
000020  ed9f0bcd          VLDR     d0,|L1.856|
000024  eeb08a40          VMOV.F32 s16,s0
000028  eef08a60          VMOV.F32 s17,s1
;;;420      uint32_t i, rowCnt, flag = 0U, j, loopCnt, k, l;      /* loop counters */
00002c  2000              MOVS     r0,#0
00002e  9004              STR      r0,[sp,#0x10]
;;;421      arm_status status;                             /* status of matrix inverse */
;;;422    
;;;423    #ifdef ARM_MATH_MATRIX_CHECK
;;;424    
;;;425      /* Check for matrix mismatch condition */
;;;426      if ((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;427         || (pSrc->numRows != pDst->numRows))
;;;428      {
;;;429        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;430        status = ARM_MATH_SIZE_MISMATCH;
;;;431      }
;;;432      else
;;;433    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;434      {
;;;435    
;;;436        /*--------------------------------------------------------------------------------------------------------------
;;;437    	 * Matrix Inverse can be solved using elementary row operations.
;;;438    	 *
;;;439    	 *	Gauss-Jordan Method:
;;;440    	 *
;;;441    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an
;;;442    	 *        augmented matrix as follows:
;;;443    	 *				        _  _	      _	    _	   _   _         _	       _
;;;444    	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |
;;;445    	 *					   |  |            | | |        |   |   =   |           |
;;;446    	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|
;;;447    	 *
;;;448    	 *		2. In our implementation, pDst Matrix is used as identity matrix.
;;;449    	 *
;;;450    	 *		3. Begin with the first row. Let i = 1.
;;;451    	 *
;;;452    	 *	    4. Check to see if the pivot for row i is zero.
;;;453    	 *		   The pivot is the element of the main diagonal that is on the current row.
;;;454    	 *		   For instance, if working with row i, then the pivot element is aii.
;;;455    	 *		   If the pivot is zero, exchange that row with a row below it that does not
;;;456    	 *		   contain a zero in column i. If this is not possible, then an inverse
;;;457    	 *		   to that matrix does not exist.
;;;458    	 *
;;;459    	 *	    5. Divide every element of row i by the pivot.
;;;460    	 *
;;;461    	 *	    6. For every row below and  row i, replace that row with the sum of that row and
;;;462    	 *		   a multiple of row i so that each new element in column i below row i is zero.
;;;463    	 *
;;;464    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros
;;;465    	 *		   for every element below and above the main diagonal.
;;;466    	 *
;;;467    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).
;;;468    	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).
;;;469    	 *----------------------------------------------------------------------------------------------------------------*/
;;;470    
;;;471        /* Working pointer for destination matrix */
;;;472        pOutT1 = pOut;
000030  9d0c              LDR      r5,[sp,#0x30]
;;;473    
;;;474        /* Loop over the number of rows */
;;;475        rowCnt = numRows;
000032  f8cdb014          STR      r11,[sp,#0x14]
;;;476    
;;;477        /* Making the destination matrix as identity matrix */
;;;478        while (rowCnt > 0U)
000036  e01b              B        |L1.112|
                  |L1.56|
;;;479        {
;;;480          /* Writing all zeroes in lower triangle of the destination matrix */
;;;481          j = numRows - rowCnt;
000038  9805              LDR      r0,[sp,#0x14]
00003a  ebab0600          SUB      r6,r11,r0
;;;482          while (j > 0U)
00003e  e004              B        |L1.74|
                  |L1.64|
;;;483          {
;;;484            *pOutT1++ = 0.0f;
000040  ed9f0bc5          VLDR     d0,|L1.856|
000044  eca50b02          VSTM     r5!,{d0}
;;;485            j--;
000048  1e76              SUBS     r6,r6,#1
                  |L1.74|
00004a  2e00              CMP      r6,#0                 ;482
00004c  d1f8              BNE      |L1.64|
;;;486          }
;;;487    
;;;488          /* Writing all ones in the diagonal of the destination matrix */
;;;489          *pOutT1++ = 1.0f;
00004e  ed9f0bc4          VLDR     d0,|L1.864|
000052  eca50b02          VSTM     r5!,{d0}
;;;490    
;;;491          /* Writing all zeroes in upper triangle of the destination matrix */
;;;492          j = rowCnt - 1U;
000056  9805              LDR      r0,[sp,#0x14]
000058  1e46              SUBS     r6,r0,#1
;;;493          while (j > 0U)
00005a  e004              B        |L1.102|
                  |L1.92|
;;;494          {
;;;495            *pOutT1++ = 0.0f;
00005c  ed9f0bbe          VLDR     d0,|L1.856|
000060  eca50b02          VSTM     r5!,{d0}
;;;496            j--;
000064  1e76              SUBS     r6,r6,#1
                  |L1.102|
000066  2e00              CMP      r6,#0                 ;493
000068  d1f8              BNE      |L1.92|
;;;497          }
;;;498    
;;;499          /* Decrement the loop counter */
;;;500          rowCnt--;
00006a  9805              LDR      r0,[sp,#0x14]
00006c  1e40              SUBS     r0,r0,#1
00006e  9005              STR      r0,[sp,#0x14]
                  |L1.112|
000070  9805              LDR      r0,[sp,#0x14]         ;478
000072  2800              CMP      r0,#0                 ;478
000074  d1e0              BNE      |L1.56|
;;;501        }
;;;502    
;;;503        /* Loop over the number of columns of the input matrix.
;;;504           All the elements in each column are processed by the row operations */
;;;505        loopCnt = numCols;
000076  9403              STR      r4,[sp,#0xc]
;;;506    
;;;507        /* Index modifier to navigate through the columns */
;;;508        l = 0U;
000078  4680              MOV      r8,r0
;;;509        //for(loopCnt = 0U; loopCnt < numCols; loopCnt++)
;;;510        while (loopCnt > 0U)
00007a  e134              B        |L1.742|
                  |L1.124|
;;;511        {
;;;512          /* Check if the pivot element is zero..
;;;513           * If it is zero then interchange the row with non zero row below.
;;;514           * If there is no non zero element to replace in the rows below,
;;;515           * then the matrix is Singular. */
;;;516    
;;;517          /* Working pointer for the input matrix that points
;;;518           * to the pivot element of the particular row  */
;;;519          pInT1 = pIn + (l * numCols);
00007c  fb08f004          MUL      r0,r8,r4
000080  eb0a07c0          ADD      r7,r10,r0,LSL #3
;;;520    
;;;521          /* Working pointer for the destination matrix that points
;;;522           * to the pivot element of the particular row  */
;;;523          pOutT1 = pOut + (l * numCols);
000084  fb08f004          MUL      r0,r8,r4
000088  990c              LDR      r1,[sp,#0x30]
00008a  eb0105c0          ADD      r5,r1,r0,LSL #3
;;;524    
;;;525          /* Temporary variable to hold the pivot value */
;;;526          in = *pInT1;
00008e  ed970b00          VLDR     d0,[r7,#0]
000092  eeb08a40          VMOV.F32 s16,s0
000096  eef08a60          VMOV.F32 s17,s1
;;;527    
;;;528          /* Destination pointer modifier */
;;;529          k = 1U;
00009a  2001              MOVS     r0,#1
00009c  9002              STR      r0,[sp,#8]
;;;530    
;;;531          /* Check if the pivot element is zero */
;;;532          if (*pInT1 == 0.0f)
00009e  ed971b00          VLDR     d1,[r7,#0]
0000a2  eeb00a41          VMOV.F32 s0,s2
0000a6  eef00a61          VMOV.F32 s1,s3
0000aa  ed9f1bab          VLDR     d1,|L1.856|
0000ae  ec532b11          VMOV     r2,r3,d1
0000b2  ec510b10          VMOV     r0,r1,d0
0000b6  f7fffffe          BL       __aeabi_cdcmpeq
0000ba  d155              BNE      |L1.360|
;;;533          {
;;;534            /* Loop over the number rows present below */
;;;535            for (i = (l + 1U); i < numRows; i++)
0000bc  f1080901          ADD      r9,r8,#1
0000c0  e04f              B        |L1.354|
                  |L1.194|
;;;536            {
;;;537              /* Update the input and destination pointers */
;;;538              pInT2 = pInT1 + (numCols * l);
0000c2  fb04f008          MUL      r0,r4,r8
0000c6  eb0700c0          ADD      r0,r7,r0,LSL #3
0000ca  900b              STR      r0,[sp,#0x2c]
;;;539              pOutT2 = pOutT1 + (numCols * k);
0000cc  9802              LDR      r0,[sp,#8]
0000ce  4360              MULS     r0,r4,r0
0000d0  eb0500c0          ADD      r0,r5,r0,LSL #3
0000d4  900a              STR      r0,[sp,#0x28]
;;;540    
;;;541              /* Check if there is a non zero pivot element to
;;;542               * replace in the rows below */
;;;543              if (*pInT2 != 0.0f)
0000d6  980b              LDR      r0,[sp,#0x2c]
0000d8  ed901b00          VLDR     d1,[r0,#0]
0000dc  eeb00a41          VMOV.F32 s0,s2
0000e0  eef00a61          VMOV.F32 s1,s3
0000e4  ed9f1b9c          VLDR     d1,|L1.856|
0000e8  ec532b11          VMOV     r2,r3,d1
0000ec  ec510b10          VMOV     r0,r1,d0
0000f0  f7fffffe          BL       __aeabi_cdcmpeq
0000f4  d030              BEQ      |L1.344|
;;;544              {
;;;545                /* Loop over number of columns
;;;546                 * to the right of the pilot element */
;;;547                for (j = 0U; j < (numCols - l); j++)
0000f6  2600              MOVS     r6,#0
0000f8  e011              B        |L1.286|
                  |L1.250|
;;;548                {
;;;549                  /* Exchange the row elements of the input matrix */
;;;550                  Xchg = *pInT2;
0000fa  980b              LDR      r0,[sp,#0x2c]
0000fc  ed900b00          VLDR     d0,[r0,#0]
000100  eeb09a40          VMOV.F32 s18,s0
000104  eef09a60          VMOV.F32 s19,s1
;;;551                  *pInT2++ = *pInT1;
000108  ed970b00          VLDR     d0,[r7,#0]
00010c  980b              LDR      r0,[sp,#0x2c]
00010e  ed800b00          VSTR     d0,[r0,#0]
000112  980b              LDR      r0,[sp,#0x2c]
000114  3008              ADDS     r0,r0,#8
000116  900b              STR      r0,[sp,#0x2c]
;;;552                  *pInT1++ = Xchg;
000118  eca79b02          VSTM     r7!,{d9}
00011c  1c76              ADDS     r6,r6,#1              ;547
                  |L1.286|
00011e  eba40008          SUB      r0,r4,r8              ;547
000122  42b0              CMP      r0,r6                 ;547
000124  d8e9              BHI      |L1.250|
;;;553                }
;;;554    
;;;555                for (j = 0U; j < numCols; j++)
000126  2600              MOVS     r6,#0
000128  e011              B        |L1.334|
                  |L1.298|
;;;556                {
;;;557                  Xchg = *pOutT2;
00012a  980a              LDR      r0,[sp,#0x28]
00012c  ed900b00          VLDR     d0,[r0,#0]
000130  eeb09a40          VMOV.F32 s18,s0
000134  eef09a60          VMOV.F32 s19,s1
;;;558                  *pOutT2++ = *pOutT1;
000138  ed950b00          VLDR     d0,[r5,#0]
00013c  980a              LDR      r0,[sp,#0x28]
00013e  ed800b00          VSTR     d0,[r0,#0]
000142  980a              LDR      r0,[sp,#0x28]
000144  3008              ADDS     r0,r0,#8
000146  900a              STR      r0,[sp,#0x28]
;;;559                  *pOutT1++ = Xchg;
000148  eca59b02          VSTM     r5!,{d9}
00014c  1c76              ADDS     r6,r6,#1              ;555
                  |L1.334|
00014e  42a6              CMP      r6,r4                 ;555
000150  d3eb              BCC      |L1.298|
;;;560                }
;;;561    
;;;562                /* Flag to indicate whether exchange is done or not */
;;;563                flag = 1U;
000152  2001              MOVS     r0,#1
000154  9004              STR      r0,[sp,#0x10]
;;;564    
;;;565                /* Break after exchange is done */
;;;566                break;
000156  e006              B        |L1.358|
                  |L1.344|
;;;567              }
;;;568    
;;;569              /* Update the destination pointer modifier */
;;;570              k++;
000158  9802              LDR      r0,[sp,#8]
00015a  1c40              ADDS     r0,r0,#1
00015c  9002              STR      r0,[sp,#8]
00015e  f1090901          ADD      r9,r9,#1              ;535
                  |L1.354|
000162  45d9              CMP      r9,r11                ;535
000164  d3ad              BCC      |L1.194|
                  |L1.358|
000166  bf00              NOP                            ;566
                  |L1.360|
;;;571            }
;;;572          }
;;;573    
;;;574          /* Update the status if the matrix is singular */
;;;575          if ((flag != 1U) && (in == 0.0f))
000168  9804              LDR      r0,[sp,#0x10]
00016a  2801              CMP      r0,#1
00016c  d00f              BEQ      |L1.398|
00016e  ed9f0b7a          VLDR     d0,|L1.856|
000172  ec532b10          VMOV     r2,r3,d0
000176  ec510b18          VMOV     r0,r1,d8
00017a  f7fffffe          BL       __aeabi_cdcmpeq
00017e  d106              BNE      |L1.398|
;;;576          {
;;;577            return ARM_MATH_SINGULAR;
000180  f06f0004          MVN      r0,#4
                  |L1.388|
;;;578          }
;;;579    
;;;580          /* Points to the pivot row of input and destination matrices */
;;;581          pPivotRowIn = pIn + (l * numCols);
;;;582          pPivotRowDst = pOut + (l * numCols);
;;;583    
;;;584          /* Temporary pointers to the pivot row pointers */
;;;585          pInT1 = pPivotRowIn;
;;;586          pOutT1 = pPivotRowDst;
;;;587    
;;;588          /* Pivot element of the row */
;;;589          in = *(pIn + (l * numCols));
;;;590    
;;;591          /* Loop over number of columns
;;;592           * to the right of the pilot element */
;;;593          for (j = 0U; j < (numCols - l); j++)
;;;594          {
;;;595            /* Divide each element of the row of the input matrix
;;;596             * by the pivot element */
;;;597            *pInT1 = *pInT1 / in;
;;;598            pInT1++;
;;;599          }
;;;600          for (j = 0U; j < numCols; j++)
;;;601          {
;;;602            /* Divide each element of the row of the destination matrix
;;;603             * by the pivot element */
;;;604            *pOutT1 = *pOutT1 / in;
;;;605            pOutT1++;
;;;606          }
;;;607    
;;;608          /* Replace the rows with the sum of that row and a multiple of row i
;;;609           * so that each new element in column i above row i is zero.*/
;;;610    
;;;611          /* Temporary pointers for input and destination matrices */
;;;612          pInT1 = pIn;
;;;613          pOutT1 = pOut;
;;;614    
;;;615          for (i = 0U; i < numRows; i++)
;;;616          {
;;;617            /* Check for the pivot element */
;;;618            if (i == l)
;;;619            {
;;;620              /* If the processing element is the pivot element,
;;;621                 only the columns to the right are to be processed */
;;;622              pInT1 += numCols - l;
;;;623              pOutT1 += numCols;
;;;624            }
;;;625            else
;;;626            {
;;;627              /* Element of the reference row */
;;;628              in = *pInT1;
;;;629    
;;;630              /* Working pointers for input and destination pivot rows */
;;;631              pPRT_in = pPivotRowIn;
;;;632              pPRT_pDst = pPivotRowDst;
;;;633    
;;;634              /* Loop over the number of columns to the right of the pivot element,
;;;635                 to replace the elements in the input matrix */
;;;636              for (j = 0U; j < (numCols - l); j++)
;;;637              {
;;;638                /* Replace the element by the sum of that row
;;;639                   and a multiple of the reference row  */
;;;640                *pInT1 = *pInT1 - (in * *pPRT_in++);
;;;641                pInT1++;
;;;642              }
;;;643              /* Loop over the number of columns to
;;;644                 replace the elements in the destination matrix */
;;;645              for (j = 0U; j < numCols; j++)
;;;646              {
;;;647                /* Replace the element by the sum of that row
;;;648                   and a multiple of the reference row  */
;;;649                *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
;;;650                pOutT1++;
;;;651              }
;;;652    
;;;653            }
;;;654            /* Increment the temporary input pointer */
;;;655            pInT1 = pInT1 + l;
;;;656          }
;;;657          /* Increment the input pointer */
;;;658          pIn++;
;;;659    
;;;660          /* Decrement the loop counter */
;;;661          loopCnt--;
;;;662          /* Increment the index modifier */
;;;663          l++;
;;;664        }
;;;665    
;;;666    
;;;667    #endif /* #if defined (ARM_MATH_DSP) */
;;;668    
;;;669        /* Set status as ARM_MATH_SUCCESS */
;;;670        status = ARM_MATH_SUCCESS;
;;;671    
;;;672        if ((flag != 1U) && (in == 0.0f))
;;;673        {
;;;674          pIn = pSrc->pData;
;;;675          for (i = 0; i < numRows * numCols; i++)
;;;676          {
;;;677            if (pIn[i] != 0.0f)
;;;678                break;
;;;679          }
;;;680    
;;;681          if (i == numRows * numCols)
;;;682            status = ARM_MATH_SINGULAR;
;;;683        }
;;;684      }
;;;685      /* Return to application */
;;;686      return (status);
;;;687    }
000184  b00d              ADD      sp,sp,#0x34
000186  ecbd8b06          VPOP     {d8-d10}
00018a  e8bd8ffc          POP      {r2-r11,pc}
                  |L1.398|
00018e  fb08f004          MUL      r0,r8,r4              ;581
000192  eb0a00c0          ADD      r0,r10,r0,LSL #3      ;581
000196  9009              STR      r0,[sp,#0x24]         ;581
000198  fb08f004          MUL      r0,r8,r4              ;582
00019c  990c              LDR      r1,[sp,#0x30]         ;582
00019e  eb0100c0          ADD      r0,r1,r0,LSL #3       ;582
0001a2  9007              STR      r0,[sp,#0x1c]         ;582
0001a4  9f09              LDR      r7,[sp,#0x24]         ;585
0001a6  9d07              LDR      r5,[sp,#0x1c]         ;586
0001a8  fb08f004          MUL      r0,r8,r4              ;589
0001ac  eb0a00c0          ADD      r0,r10,r0,LSL #3      ;589
0001b0  ed900b00          VLDR     d0,[r0,#0]            ;589
0001b4  eeb08a40          VMOV.F32 s16,s0                ;589
0001b8  eef08a60          VMOV.F32 s17,s1                ;589
0001bc  2600              MOVS     r6,#0                 ;593
0001be  e00f              B        |L1.480|
                  |L1.448|
0001c0  ed971b00          VLDR     d1,[r7,#0]            ;597
0001c4  eeb00a41          VMOV.F32 s0,s2                 ;597
0001c8  eef00a61          VMOV.F32 s1,s3                 ;597
0001cc  ec532b18          VMOV     r2,r3,d8              ;597
0001d0  ec510b10          VMOV     r0,r1,d0              ;597
0001d4  f7fffffe          BL       __aeabi_ddiv
0001d8  e9c70100          STRD     r0,r1,[r7,#0]         ;597
0001dc  3708              ADDS     r7,r7,#8              ;598
0001de  1c76              ADDS     r6,r6,#1              ;593
                  |L1.480|
0001e0  eba40008          SUB      r0,r4,r8              ;593
0001e4  42b0              CMP      r0,r6                 ;593
0001e6  d8eb              BHI      |L1.448|
0001e8  2600              MOVS     r6,#0                 ;600
0001ea  e00f              B        |L1.524|
                  |L1.492|
0001ec  ed951b00          VLDR     d1,[r5,#0]            ;604
0001f0  eeb00a41          VMOV.F32 s0,s2                 ;604
0001f4  eef00a61          VMOV.F32 s1,s3                 ;604
0001f8  ec532b18          VMOV     r2,r3,d8              ;604
0001fc  ec510b10          VMOV     r0,r1,d0              ;604
000200  f7fffffe          BL       __aeabi_ddiv
000204  e9c50100          STRD     r0,r1,[r5,#0]         ;604
000208  3508              ADDS     r5,r5,#8              ;605
00020a  1c76              ADDS     r6,r6,#1              ;600
                  |L1.524|
00020c  42a6              CMP      r6,r4                 ;600
00020e  d3ed              BCC      |L1.492|
000210  4657              MOV      r7,r10                ;612
000212  9d0c              LDR      r5,[sp,#0x30]         ;613
000214  f04f0900          MOV      r9,#0                 ;615
000218  e05c              B        |L1.724|
                  |L1.538|
00021a  45c1              CMP      r9,r8                 ;618
00021c  d106              BNE      |L1.556|
00021e  eba40008          SUB      r0,r4,r8              ;622
000222  eb0707c0          ADD      r7,r7,r0,LSL #3       ;622
000226  eb0505c4          ADD      r5,r5,r4,LSL #3       ;623
00022a  e04f              B        |L1.716|
                  |L1.556|
00022c  ed970b00          VLDR     d0,[r7,#0]            ;628
000230  eeb08a40          VMOV.F32 s16,s0                ;628
000234  eef08a60          VMOV.F32 s17,s1                ;628
000238  9809              LDR      r0,[sp,#0x24]         ;631
00023a  9008              STR      r0,[sp,#0x20]         ;631
00023c  9807              LDR      r0,[sp,#0x1c]         ;632
00023e  9006              STR      r0,[sp,#0x18]         ;632
000240  2600              MOVS     r6,#0                 ;636
000242  e01d              B        |L1.640|
                  |L1.580|
000244  9808              LDR      r0,[sp,#0x20]         ;640
000246  ecb01b02          VLDM     r0!,{d1}              ;640
00024a  eeb00a41          VMOV.F32 s0,s2                 ;640
00024e  eef00a61          VMOV.F32 s1,s3                 ;640
000252  ec532b10          VMOV     r2,r3,d0              ;640
000256  9008              STR      r0,[sp,#0x20]         ;640
000258  ec510b18          VMOV     r0,r1,d8              ;640
00025c  f7fffffe          BL       __aeabi_dmul
000260  ec410b1a          VMOV     d10,r0,r1             ;640
000264  ed971b00          VLDR     d1,[r7,#0]            ;640
000268  eeb00a41          VMOV.F32 s0,s2                 ;640
00026c  eef00a61          VMOV.F32 s1,s3                 ;640
000270  ec532b10          VMOV     r2,r3,d0              ;640
000274  f7fffffe          BL       __aeabi_drsub
000278  e9c70100          STRD     r0,r1,[r7,#0]         ;640
00027c  3708              ADDS     r7,r7,#8              ;641
00027e  1c76              ADDS     r6,r6,#1              ;636
                  |L1.640|
000280  eba40008          SUB      r0,r4,r8              ;636
000284  42b0              CMP      r0,r6                 ;636
000286  d8dd              BHI      |L1.580|
000288  2600              MOVS     r6,#0                 ;645
00028a  e01d              B        |L1.712|
                  |L1.652|
00028c  9806              LDR      r0,[sp,#0x18]         ;649
00028e  ecb01b02          VLDM     r0!,{d1}              ;649
000292  eeb00a41          VMOV.F32 s0,s2                 ;649
000296  eef00a61          VMOV.F32 s1,s3                 ;649
00029a  ec532b10          VMOV     r2,r3,d0              ;649
00029e  9006              STR      r0,[sp,#0x18]         ;649
0002a0  ec510b18          VMOV     r0,r1,d8              ;649
0002a4  f7fffffe          BL       __aeabi_dmul
0002a8  ec410b1a          VMOV     d10,r0,r1             ;649
0002ac  ed951b00          VLDR     d1,[r5,#0]            ;649
0002b0  eeb00a41          VMOV.F32 s0,s2                 ;649
0002b4  eef00a61          VMOV.F32 s1,s3                 ;649
0002b8  ec532b10          VMOV     r2,r3,d0              ;649
0002bc  f7fffffe          BL       __aeabi_drsub
0002c0  e9c50100          STRD     r0,r1,[r5,#0]         ;649
0002c4  3508              ADDS     r5,r5,#8              ;650
0002c6  1c76              ADDS     r6,r6,#1              ;645
                  |L1.712|
0002c8  42a6              CMP      r6,r4                 ;645
0002ca  d3df              BCC      |L1.652|
                  |L1.716|
0002cc  eb0707c8          ADD      r7,r7,r8,LSL #3       ;655
0002d0  f1090901          ADD      r9,r9,#1              ;615
                  |L1.724|
0002d4  45d9              CMP      r9,r11                ;615
0002d6  d3a0              BCC      |L1.538|
0002d8  f10a0a08          ADD      r10,r10,#8            ;658
0002dc  9803              LDR      r0,[sp,#0xc]          ;661
0002de  1e40              SUBS     r0,r0,#1              ;661
0002e0  9003              STR      r0,[sp,#0xc]          ;661
0002e2  f1080801          ADD      r8,r8,#1              ;663
                  |L1.742|
0002e6  9803              LDR      r0,[sp,#0xc]          ;510
0002e8  2800              CMP      r0,#0                 ;510
0002ea  f47faec7          BNE      |L1.124|
0002ee  9001              STR      r0,[sp,#4]            ;670
0002f0  9804              LDR      r0,[sp,#0x10]         ;672
0002f2  2801              CMP      r0,#1                 ;672
0002f4  d02e              BEQ      |L1.852|
0002f6  ed9f0b18          VLDR     d0,|L1.856|
0002fa  ec532b10          VMOV     r2,r3,d0              ;672
0002fe  ec510b18          VMOV     r0,r1,d8              ;672
000302  f7fffffe          BL       __aeabi_cdcmpeq
000306  d125              BNE      |L1.852|
000308  9813              LDR      r0,[sp,#0x4c]         ;674
00030a  f8d0a004          LDR      r10,[r0,#4]           ;674
00030e  f04f0900          MOV      r9,#0                 ;675
000312  e013              B        |L1.828|
                  |L1.788|
000314  eb0a00c9          ADD      r0,r10,r9,LSL #3      ;677
000318  ed901b00          VLDR     d1,[r0,#0]            ;677
00031c  eeb00a41          VMOV.F32 s0,s2                 ;677
000320  eef00a61          VMOV.F32 s1,s3                 ;677
000324  ed9f1b0c          VLDR     d1,|L1.856|
000328  ec532b11          VMOV     r2,r3,d1              ;677
00032c  ec510b10          VMOV     r0,r1,d0              ;677
000330  f7fffffe          BL       __aeabi_cdcmpeq
000334  d000              BEQ      |L1.824|
000336  e005              B        |L1.836|
                  |L1.824|
000338  f1090901          ADD      r9,r9,#1              ;675
                  |L1.828|
00033c  fb0bf004          MUL      r0,r11,r4             ;675
000340  4548              CMP      r0,r9                 ;675
000342  d8e7              BHI      |L1.788|
                  |L1.836|
000344  bf00              NOP                            ;678
000346  fb0bf004          MUL      r0,r11,r4             ;681
00034a  4548              CMP      r0,r9                 ;681
00034c  d102              BNE      |L1.852|
00034e  f06f0004          MVN      r0,#4                 ;682
000352  9001              STR      r0,[sp,#4]            ;682
                  |L1.852|
000354  9801              LDR      r0,[sp,#4]            ;686
000356  e715              B        |L1.388|
;;;688    
                          ENDP

                  |L1.856|
000358  00000000          DCFD     0x0000000000000000 ; 0
00035c  00000000
                  |L1.864|
000360  00000000          DCFD     0x3ff0000000000000 ; 1
000364  3ff00000

;*** Start embedded assembler ***

#line 1 "..\\stm32LIB\\Device\\arm_mat_inverse_f64.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____REV16|
#line 388 "..\\stm32LIB\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_arm_mat_inverse_f64_c_3978fe55____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____REVSH|
#line 402
|__asm___21_arm_mat_inverse_f64_c_3978fe55____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f64_c_3978fe55____RRX|
#line 587
|__asm___21_arm_mat_inverse_f64_c_3978fe55____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
