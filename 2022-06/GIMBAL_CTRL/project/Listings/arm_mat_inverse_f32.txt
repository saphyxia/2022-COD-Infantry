; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\arm_mat_inverse_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_inverse_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\stm32LIB\inc -I..\stm32LIB\CMSIS\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\user\_Dsp\Include -I..\user\_Algorithms -I..\user\_Bsp -I..\user\_Device -I..\user\_Task -I..\system -I..\stm32LIB\CMSIS -I..\system -I..\FreeRTOS -I..\user -I.\RTE\_COD_Gimbal_Task -IC:\keil_v5_project\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=528 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM4 -D__FPU_PRESENT --omf_browse=.\objects\arm_mat_inverse_f32.crf ..\stm32LIB\Device\arm_mat_inverse_f32.c]
                          THUMB

                          AREA ||i.arm_mat_inverse_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_inverse_f32 PROC
;;;84     
;;;85     arm_status arm_mat_inverse_f32(
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;86       const arm_matrix_instance_f32 * pSrc,
;;;87       arm_matrix_instance_f32 * pDst)
;;;88     {
000004  b088              SUB      sp,sp,#0x20
000006  4681              MOV      r9,r0
;;;89       float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
000008  f8d98004          LDR      r8,[r9,#4]
;;;90       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
00000c  9809              LDR      r0,[sp,#0x24]
00000e  f8d0a004          LDR      r10,[r0,#4]
;;;91       float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
;;;92       float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
;;;93       float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data matrix pointer */
;;;94       uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
000012  f8b9c000          LDRH     r12,[r9,#0]
;;;95       uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
000016  f8b92002          LDRH     r2,[r9,#2]
;;;96     
;;;97     #ifndef ARM_MATH_CM0_FAMILY
;;;98       float32_t maxC;                                /* maximum value in the column */
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
00001a  ed9f2abc          VLDR     s4,|L1.780|
00001e  eeb00a42          VMOV.F32 s0,s4
;;;103      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
000022  2000              MOVS     r0,#0
000024  9003              STR      r0,[sp,#0xc]
;;;104      arm_status status;                             /* status of matrix inverse */
;;;105    
;;;106    #ifdef ARM_MATH_MATRIX_CHECK
;;;107    
;;;108    
;;;109      /* Check for matrix mismatch condition */
;;;110      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;111         || (pSrc->numRows != pDst->numRows))
;;;112      {
;;;113        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;114        status = ARM_MATH_SIZE_MISMATCH;
;;;115      }
;;;116      else
;;;117    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;118    
;;;119      {
;;;120    
;;;121        /*--------------------------------------------------------------------------------------------------------------    
;;;122    	 * Matrix Inverse can be solved using elementary row operations.    
;;;123    	 *    
;;;124    	 *	Gauss-Jordan Method:    
;;;125    	 *    
;;;126    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an    
;;;127    	 *        augmented matrix as follows:    
;;;128    	 *				        _ 	      	       _         _	       _    
;;;129    	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |    
;;;130    	 *					   |           |        |   =   |           |    
;;;131    	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|    
;;;132    	 *    
;;;133    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;134    	 *    
;;;135    	 *		3. Begin with the first row. Let i = 1.    
;;;136    	 *    
;;;137    	 *	    4. Check to see if the pivot for column i is the greatest of the column.    
;;;138    	 *		   The pivot is the element of the main diagonal that is on the current row.    
;;;139    	 *		   For instance, if working with row i, then the pivot element is aii.    
;;;140    	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
;;;141    	 *		   below it that does contain the most significant value in column i. If the most
;;;142    	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
;;;143    	 *		   The most significant value of the column is the absolute maximum.
;;;144    	 *    
;;;145    	 *	    5. Divide every element of row i by the pivot.    
;;;146    	 *    
;;;147    	 *	    6. For every row below and  row i, replace that row with the sum of that row and    
;;;148    	 *		   a multiple of row i so that each new element in column i below row i is zero.    
;;;149    	 *    
;;;150    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros    
;;;151    	 *		   for every element below and above the main diagonal.    
;;;152    	 *    
;;;153    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).    
;;;154    	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).    
;;;155    	 *----------------------------------------------------------------------------------------------------------------*/
;;;156    
;;;157        /* Working pointer for destination matrix */
;;;158        pOutT1 = pOut;
000026  4656              MOV      r6,r10
;;;159    
;;;160        /* Loop over the number of rows */
;;;161        rowCnt = numRows;
000028  46e6              MOV      lr,r12
;;;162    
;;;163        /* Making the destination matrix as identity matrix */
;;;164        while(rowCnt > 0u)
00002a  e019              B        |L1.96|
                  |L1.44|
;;;165        {
;;;166          /* Writing all zeroes in lower triangle of the destination matrix */
;;;167          j = numRows - rowCnt;
00002c  ebac030e          SUB      r3,r12,lr
;;;168          while(j > 0u)
000030  e004              B        |L1.60|
                  |L1.50|
;;;169          {
;;;170            *pOutT1++ = 0.0f;
000032  ed9f2ab6          VLDR     s4,|L1.780|
000036  eca62a01          VSTM     r6!,{s4}
;;;171            j--;
00003a  1e5b              SUBS     r3,r3,#1
                  |L1.60|
00003c  2b00              CMP      r3,#0                 ;168
00003e  d1f8              BNE      |L1.50|
;;;172          }
;;;173    
;;;174          /* Writing all ones in the diagonal of the destination matrix */
;;;175          *pOutT1++ = 1.0f;
000040  eeb72a00          VMOV.F32 s4,#1.00000000
000044  eca62a01          VSTM     r6!,{s4}
;;;176    
;;;177          /* Writing all zeroes in upper triangle of the destination matrix */
;;;178          j = rowCnt - 1u;
000048  f1ae0301          SUB      r3,lr,#1
;;;179          while(j > 0u)
00004c  e004              B        |L1.88|
                  |L1.78|
;;;180          {
;;;181            *pOutT1++ = 0.0f;
00004e  ed9f2aaf          VLDR     s4,|L1.780|
000052  eca62a01          VSTM     r6!,{s4}
;;;182            j--;
000056  1e5b              SUBS     r3,r3,#1
                  |L1.88|
000058  2b00              CMP      r3,#0                 ;179
00005a  d1f8              BNE      |L1.78|
;;;183          }
;;;184    
;;;185          /* Decrement the loop counter */
;;;186          rowCnt--;
00005c  f1ae0e01          SUB      lr,lr,#1
                  |L1.96|
000060  f1be0f00          CMP      lr,#0                 ;164
000064  d1e2              BNE      |L1.44|
;;;187        }
;;;188    
;;;189        /* Loop over the number of columns of the input matrix.    
;;;190           All the elements in each column are processed by the row operations */
;;;191        loopCnt = numCols;
000066  9202              STR      r2,[sp,#8]
;;;192    
;;;193        /* Index modifier to navigate through the columns */
;;;194        l = 0u;
000068  2400              MOVS     r4,#0
;;;195    
;;;196        while(loopCnt > 0u)
00006a  e124              B        |L1.694|
                  |L1.108|
;;;197        {
;;;198          /* Check if the pivot element is zero..    
;;;199           * If it is zero then interchange the row with non zero row below.    
;;;200           * If there is no non zero element to replace in the rows below,    
;;;201           * then the matrix is Singular. */
;;;202    
;;;203          /* Working pointer for the input matrix that points    
;;;204           * to the pivot element of the particular row  */
;;;205          pInT1 = pIn + (l * numCols);
00006c  fb04f002          MUL      r0,r4,r2
000070  eb080180          ADD      r1,r8,r0,LSL #2
;;;206    
;;;207          /* Working pointer for the destination matrix that points    
;;;208           * to the pivot element of the particular row  */
;;;209          pOutT1 = pOut + (l * numCols);
000074  fb04f002          MUL      r0,r4,r2
000078  eb0a0680          ADD      r6,r10,r0,LSL #2
;;;210    
;;;211          /* Temporary variable to hold the pivot value */
;;;212          in = *pInT1;
00007c  ed912a00          VLDR     s4,[r1,#0]
000080  eeb00a42          VMOV.F32 s0,s4
;;;213    
;;;214          /* Grab the most significant value from column l */
;;;215          maxC = 0;
000084  ed9f2aa1          VLDR     s4,|L1.780|
000088  eef00a42          VMOV.F32 s1,s4
;;;216          for (i = l; i < numRows; i++)
00008c  4627              MOV      r7,r4
00008e  e028              B        |L1.226|
                  |L1.144|
;;;217          {
;;;218            maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
000090  ed912a00          VLDR     s4,[r1,#0]
000094  eeb52ac0          VCMPE.F32 s4,#0.0
000098  eef1fa10          VMRS     APSR_nzcv,FPSCR
00009c  dd0c              BLE      |L1.184|
00009e  ed912a00          VLDR     s4,[r1,#0]
0000a2  eeb42ae0          VCMPE.F32 s4,s1
0000a6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000aa  dd02              BLE      |L1.178|
0000ac  ed912a00          VLDR     s4,[r1,#0]
0000b0  e012              B        |L1.216|
                  |L1.178|
0000b2  eeb02a60          VMOV.F32 s4,s1
0000b6  e00f              B        |L1.216|
                  |L1.184|
0000b8  ed912a00          VLDR     s4,[r1,#0]
0000bc  eeb12a42          VNEG.F32 s4,s4
0000c0  eeb42ae0          VCMPE.F32 s4,s1
0000c4  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000c8  dd04              BLE      |L1.212|
0000ca  ed912a00          VLDR     s4,[r1,#0]
0000ce  eeb12a42          VNEG.F32 s4,s4
0000d2  e001              B        |L1.216|
                  |L1.212|
0000d4  eeb02a60          VMOV.F32 s4,s1
                  |L1.216|
0000d8  eef00a42          VMOV.F32 s1,s4
;;;219            pInT1 += numCols;
0000dc  eb010182          ADD      r1,r1,r2,LSL #2
0000e0  1c7f              ADDS     r7,r7,#1              ;216
                  |L1.226|
0000e2  4567              CMP      r7,r12                ;216
0000e4  d3d4              BCC      |L1.144|
;;;220          }
;;;221    
;;;222          /* Update the status if the matrix is singular */
;;;223          if(maxC == 0.0f)
0000e6  eef50ac0          VCMPE.F32 s1,#0.0
0000ea  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ee  d104              BNE      |L1.250|
;;;224          {
;;;225            return ARM_MATH_SINGULAR;
0000f0  f06f0004          MVN      r0,#4
                  |L1.244|
;;;226          }
;;;227    
;;;228          /* Restore pInT1  */
;;;229          pInT1 = pIn;
;;;230    
;;;231          /* Destination pointer modifier */
;;;232          k = 1u;
;;;233          
;;;234          /* Check if the pivot element is the most significant of the column */
;;;235          if( (in > 0.0f ? in : -in) != maxC)
;;;236          {
;;;237            /* Loop over the number rows present below */
;;;238            i = numRows - (l + 1u);
;;;239    
;;;240            while(i > 0u)
;;;241            {
;;;242              /* Update the input and destination pointers */
;;;243              pInT2 = pInT1 + (numCols * l);
;;;244              pOutT2 = pOutT1 + (numCols * k);
;;;245    
;;;246              /* Look for the most significant element to    
;;;247               * replace in the rows below */
;;;248              if((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
;;;249              {
;;;250                /* Loop over number of columns    
;;;251                 * to the right of the pilot element */
;;;252                j = numCols - l;
;;;253    
;;;254                while(j > 0u)
;;;255                {
;;;256                  /* Exchange the row elements of the input matrix */
;;;257                  Xchg = *pInT2;
;;;258                  *pInT2++ = *pInT1;
;;;259                  *pInT1++ = Xchg;
;;;260    
;;;261                  /* Decrement the loop counter */
;;;262                  j--;
;;;263                }
;;;264    
;;;265                /* Loop over number of columns of the destination matrix */
;;;266                j = numCols;
;;;267    
;;;268                while(j > 0u)
;;;269                {
;;;270                  /* Exchange the row elements of the destination matrix */
;;;271                  Xchg = *pOutT2;
;;;272                  *pOutT2++ = *pOutT1;
;;;273                  *pOutT1++ = Xchg;
;;;274    
;;;275                  /* Decrement the loop counter */
;;;276                  j--;
;;;277                }
;;;278    
;;;279                /* Flag to indicate whether exchange is done or not */
;;;280                flag = 1u;
;;;281    
;;;282                /* Break after exchange is done */
;;;283                break;
;;;284              }
;;;285    
;;;286              /* Update the destination pointer modifier */
;;;287              k++;
;;;288    
;;;289              /* Decrement the loop counter */
;;;290              i--;
;;;291            }
;;;292          }
;;;293    
;;;294          /* Update the status if the matrix is singular */
;;;295          if((flag != 1u) && (in == 0.0f))
;;;296          {
;;;297            return ARM_MATH_SINGULAR;
;;;298          }
;;;299    
;;;300          /* Points to the pivot row of input and destination matrices */
;;;301          pPivotRowIn = pIn + (l * numCols);
;;;302          pPivotRowDst = pOut + (l * numCols);
;;;303    
;;;304          /* Temporary pointers to the pivot row pointers */
;;;305          pInT1 = pPivotRowIn;
;;;306          pInT2 = pPivotRowDst;
;;;307    
;;;308          /* Pivot element of the row */
;;;309          in = *pPivotRowIn;
;;;310    
;;;311          /* Loop over number of columns    
;;;312           * to the right of the pilot element */
;;;313          j = (numCols - l);
;;;314    
;;;315          while(j > 0u)
;;;316          {
;;;317            /* Divide each element of the row of the input matrix    
;;;318             * by the pivot element */
;;;319            in1 = *pInT1;
;;;320            *pInT1++ = in1 / in;
;;;321    
;;;322            /* Decrement the loop counter */
;;;323            j--;
;;;324          }
;;;325    
;;;326          /* Loop over number of columns of the destination matrix */
;;;327          j = numCols;
;;;328    
;;;329          while(j > 0u)
;;;330          {
;;;331            /* Divide each element of the row of the destination matrix    
;;;332             * by the pivot element */
;;;333            in1 = *pInT2;
;;;334            *pInT2++ = in1 / in;
;;;335    
;;;336            /* Decrement the loop counter */
;;;337            j--;
;;;338          }
;;;339    
;;;340          /* Replace the rows with the sum of that row and a multiple of row i    
;;;341           * so that each new element in column i above row i is zero.*/
;;;342    
;;;343          /* Temporary pointers for input and destination matrices */
;;;344          pInT1 = pIn;
;;;345          pInT2 = pOut;
;;;346    
;;;347          /* index used to check for pivot element */
;;;348          i = 0u;
;;;349    
;;;350          /* Loop over number of rows */
;;;351          /*  to be replaced by the sum of that row and a multiple of row i */
;;;352          k = numRows;
;;;353    
;;;354          while(k > 0u)
;;;355          {
;;;356            /* Check for the pivot element */
;;;357            if(i == l)
;;;358            {
;;;359              /* If the processing element is the pivot element,    
;;;360                 only the columns to the right are to be processed */
;;;361              pInT1 += numCols - l;
;;;362    
;;;363              pInT2 += numCols;
;;;364            }
;;;365            else
;;;366            {
;;;367              /* Element of the reference row */
;;;368              in = *pInT1;
;;;369    
;;;370              /* Working pointers for input and destination pivot rows */
;;;371              pPRT_in = pPivotRowIn;
;;;372              pPRT_pDst = pPivotRowDst;
;;;373    
;;;374              /* Loop over the number of columns to the right of the pivot element,    
;;;375                 to replace the elements in the input matrix */
;;;376              j = (numCols - l);
;;;377    
;;;378              while(j > 0u)
;;;379              {
;;;380                /* Replace the element by the sum of that row    
;;;381                   and a multiple of the reference row  */
;;;382                in1 = *pInT1;
;;;383                *pInT1++ = in1 - (in * *pPRT_in++);
;;;384    
;;;385                /* Decrement the loop counter */
;;;386                j--;
;;;387              }
;;;388    
;;;389              /* Loop over the number of columns to    
;;;390                 replace the elements in the destination matrix */
;;;391              j = numCols;
;;;392    
;;;393              while(j > 0u)
;;;394              {
;;;395                /* Replace the element by the sum of that row    
;;;396                   and a multiple of the reference row  */
;;;397                in1 = *pInT2;
;;;398                *pInT2++ = in1 - (in * *pPRT_pDst++);
;;;399    
;;;400                /* Decrement the loop counter */
;;;401                j--;
;;;402              }
;;;403    
;;;404            }
;;;405    
;;;406            /* Increment the temporary input pointer */
;;;407            pInT1 = pInT1 + l;
;;;408    
;;;409            /* Decrement the loop counter */
;;;410            k--;
;;;411    
;;;412            /* Increment the pivot index */
;;;413            i++;
;;;414          }
;;;415    
;;;416          /* Increment the input pointer */
;;;417          pIn++;
;;;418    
;;;419          /* Decrement the loop counter */
;;;420          loopCnt--;
;;;421    
;;;422          /* Increment the index modifier */
;;;423          l++;
;;;424        }
;;;425    
;;;426    
;;;427    #else
;;;428    
;;;429      /* Run the below code for Cortex-M0 */
;;;430    
;;;431      float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
;;;432      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
;;;433      arm_status status;                             /* status of matrix inverse */
;;;434    
;;;435    #ifdef ARM_MATH_MATRIX_CHECK
;;;436    
;;;437      /* Check for matrix mismatch condition */
;;;438      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;439         || (pSrc->numRows != pDst->numRows))
;;;440      {
;;;441        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;442        status = ARM_MATH_SIZE_MISMATCH;
;;;443      }
;;;444      else
;;;445    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;446      {
;;;447    
;;;448        /*--------------------------------------------------------------------------------------------------------------       
;;;449    	 * Matrix Inverse can be solved using elementary row operations.        
;;;450    	 *        
;;;451    	 *	Gauss-Jordan Method:       
;;;452    	 *	 	       
;;;453    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an        
;;;454    	 *        augmented matrix as follows:        
;;;455    	 *				        _  _	      _	    _	   _   _         _	       _       
;;;456    	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |         
;;;457    	 *					   |  |            | | |        |   |   =   |           |        
;;;458    	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|       
;;;459    	 *					          
;;;460    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;461    	 *       
;;;462    	 *		3. Begin with the first row. Let i = 1.       
;;;463    	 *       
;;;464    	 *	    4. Check to see if the pivot for row i is zero.       
;;;465    	 *		   The pivot is the element of the main diagonal that is on the current row.       
;;;466    	 *		   For instance, if working with row i, then the pivot element is aii.       
;;;467    	 *		   If the pivot is zero, exchange that row with a row below it that does not        
;;;468    	 *		   contain a zero in column i. If this is not possible, then an inverse        
;;;469    	 *		   to that matrix does not exist.       
;;;470    	 *	       
;;;471    	 *	    5. Divide every element of row i by the pivot.       
;;;472    	 *	       
;;;473    	 *	    6. For every row below and  row i, replace that row with the sum of that row and        
;;;474    	 *		   a multiple of row i so that each new element in column i below row i is zero.       
;;;475    	 *	       
;;;476    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros       
;;;477    	 *		   for every element below and above the main diagonal.        
;;;478    	 *		   		          
;;;479    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).       
;;;480    	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).         
;;;481    	 *----------------------------------------------------------------------------------------------------------------*/
;;;482    
;;;483        /* Working pointer for destination matrix */
;;;484        pOutT1 = pOut;
;;;485    
;;;486        /* Loop over the number of rows */
;;;487        rowCnt = numRows;
;;;488    
;;;489        /* Making the destination matrix as identity matrix */
;;;490        while(rowCnt > 0u)
;;;491        {
;;;492          /* Writing all zeroes in lower triangle of the destination matrix */
;;;493          j = numRows - rowCnt;
;;;494          while(j > 0u)
;;;495          {
;;;496            *pOutT1++ = 0.0f;
;;;497            j--;
;;;498          }
;;;499    
;;;500          /* Writing all ones in the diagonal of the destination matrix */
;;;501          *pOutT1++ = 1.0f;
;;;502    
;;;503          /* Writing all zeroes in upper triangle of the destination matrix */
;;;504          j = rowCnt - 1u;
;;;505          while(j > 0u)
;;;506          {
;;;507            *pOutT1++ = 0.0f;
;;;508            j--;
;;;509          }
;;;510    
;;;511          /* Decrement the loop counter */
;;;512          rowCnt--;
;;;513        }
;;;514    
;;;515        /* Loop over the number of columns of the input matrix.     
;;;516           All the elements in each column are processed by the row operations */
;;;517        loopCnt = numCols;
;;;518    
;;;519        /* Index modifier to navigate through the columns */
;;;520        l = 0u;
;;;521        //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)   
;;;522        while(loopCnt > 0u)
;;;523        {
;;;524          /* Check if the pivot element is zero..    
;;;525           * If it is zero then interchange the row with non zero row below.   
;;;526           * If there is no non zero element to replace in the rows below,   
;;;527           * then the matrix is Singular. */
;;;528    
;;;529          /* Working pointer for the input matrix that points     
;;;530           * to the pivot element of the particular row  */
;;;531          pInT1 = pIn + (l * numCols);
;;;532    
;;;533          /* Working pointer for the destination matrix that points     
;;;534           * to the pivot element of the particular row  */
;;;535          pOutT1 = pOut + (l * numCols);
;;;536    
;;;537          /* Temporary variable to hold the pivot value */
;;;538          in = *pInT1;
;;;539    
;;;540          /* Destination pointer modifier */
;;;541          k = 1u;
;;;542    
;;;543          /* Check if the pivot element is zero */
;;;544          if(*pInT1 == 0.0f)
;;;545          {
;;;546            /* Loop over the number rows present below */
;;;547            for (i = (l + 1u); i < numRows; i++)
;;;548            {
;;;549              /* Update the input and destination pointers */
;;;550              pInT2 = pInT1 + (numCols * l);
;;;551              pOutT2 = pOutT1 + (numCols * k);
;;;552    
;;;553              /* Check if there is a non zero pivot element to     
;;;554               * replace in the rows below */
;;;555              if(*pInT2 != 0.0f)
;;;556              {
;;;557                /* Loop over number of columns     
;;;558                 * to the right of the pilot element */
;;;559                for (j = 0u; j < (numCols - l); j++)
;;;560                {
;;;561                  /* Exchange the row elements of the input matrix */
;;;562                  Xchg = *pInT2;
;;;563                  *pInT2++ = *pInT1;
;;;564                  *pInT1++ = Xchg;
;;;565                }
;;;566    
;;;567                for (j = 0u; j < numCols; j++)
;;;568                {
;;;569                  Xchg = *pOutT2;
;;;570                  *pOutT2++ = *pOutT1;
;;;571                  *pOutT1++ = Xchg;
;;;572                }
;;;573    
;;;574                /* Flag to indicate whether exchange is done or not */
;;;575                flag = 1u;
;;;576    
;;;577                /* Break after exchange is done */
;;;578                break;
;;;579              }
;;;580    
;;;581              /* Update the destination pointer modifier */
;;;582              k++;
;;;583            }
;;;584          }
;;;585    
;;;586          /* Update the status if the matrix is singular */
;;;587          if((flag != 1u) && (in == 0.0f))
;;;588          {
;;;589            return ARM_MATH_SINGULAR;
;;;590          }
;;;591    
;;;592          /* Points to the pivot row of input and destination matrices */
;;;593          pPivotRowIn = pIn + (l * numCols);
;;;594          pPivotRowDst = pOut + (l * numCols);
;;;595    
;;;596          /* Temporary pointers to the pivot row pointers */
;;;597          pInT1 = pPivotRowIn;
;;;598          pOutT1 = pPivotRowDst;
;;;599    
;;;600          /* Pivot element of the row */
;;;601          in = *(pIn + (l * numCols));
;;;602    
;;;603          /* Loop over number of columns     
;;;604           * to the right of the pilot element */
;;;605          for (j = 0u; j < (numCols - l); j++)
;;;606          {
;;;607            /* Divide each element of the row of the input matrix     
;;;608             * by the pivot element */
;;;609            *pInT1 = *pInT1 / in;
;;;610            pInT1++;
;;;611          }
;;;612          for (j = 0u; j < numCols; j++)
;;;613          {
;;;614            /* Divide each element of the row of the destination matrix     
;;;615             * by the pivot element */
;;;616            *pOutT1 = *pOutT1 / in;
;;;617            pOutT1++;
;;;618          }
;;;619    
;;;620          /* Replace the rows with the sum of that row and a multiple of row i     
;;;621           * so that each new element in column i above row i is zero.*/
;;;622    
;;;623          /* Temporary pointers for input and destination matrices */
;;;624          pInT1 = pIn;
;;;625          pOutT1 = pOut;
;;;626    
;;;627          for (i = 0u; i < numRows; i++)
;;;628          {
;;;629            /* Check for the pivot element */
;;;630            if(i == l)
;;;631            {
;;;632              /* If the processing element is the pivot element,     
;;;633                 only the columns to the right are to be processed */
;;;634              pInT1 += numCols - l;
;;;635              pOutT1 += numCols;
;;;636            }
;;;637            else
;;;638            {
;;;639              /* Element of the reference row */
;;;640              in = *pInT1;
;;;641    
;;;642              /* Working pointers for input and destination pivot rows */
;;;643              pPRT_in = pPivotRowIn;
;;;644              pPRT_pDst = pPivotRowDst;
;;;645    
;;;646              /* Loop over the number of columns to the right of the pivot element,     
;;;647                 to replace the elements in the input matrix */
;;;648              for (j = 0u; j < (numCols - l); j++)
;;;649              {
;;;650                /* Replace the element by the sum of that row     
;;;651                   and a multiple of the reference row  */
;;;652                *pInT1 = *pInT1 - (in * *pPRT_in++);
;;;653                pInT1++;
;;;654              }
;;;655              /* Loop over the number of columns to     
;;;656                 replace the elements in the destination matrix */
;;;657              for (j = 0u; j < numCols; j++)
;;;658              {
;;;659                /* Replace the element by the sum of that row     
;;;660                   and a multiple of the reference row  */
;;;661                *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
;;;662                pOutT1++;
;;;663              }
;;;664    
;;;665            }
;;;666            /* Increment the temporary input pointer */
;;;667            pInT1 = pInT1 + l;
;;;668          }
;;;669          /* Increment the input pointer */
;;;670          pIn++;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          loopCnt--;
;;;674          /* Increment the index modifier */
;;;675          l++;
;;;676        }
;;;677    
;;;678    
;;;679    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;680    
;;;681        /* Set status as ARM_MATH_SUCCESS */
;;;682        status = ARM_MATH_SUCCESS;
;;;683    
;;;684        if((flag != 1u) && (in == 0.0f))
;;;685        {
;;;686          pIn = pSrc->pData;
;;;687          for (i = 0; i < numRows * numCols; i++)
;;;688          {
;;;689            if (pIn[i] != 0.0f)
;;;690                break;
;;;691          }
;;;692          
;;;693          if (i == numRows * numCols)
;;;694            status = ARM_MATH_SINGULAR;
;;;695        }
;;;696      }
;;;697      /* Return to application */
;;;698      return (status);
;;;699    }
0000f4  b00a              ADD      sp,sp,#0x28
0000f6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.250|
0000fa  4641              MOV      r1,r8                 ;229
0000fc  2001              MOVS     r0,#1                 ;232
0000fe  9001              STR      r0,[sp,#4]            ;232
000100  eeb50ac0          VCMPE.F32 s0,#0.0               ;235
000104  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;235
000108  dd02              BLE      |L1.272|
00010a  eeb02a40          VMOV.F32 s4,s0                 ;235
00010e  e001              B        |L1.276|
                  |L1.272|
000110  eeb12a40          VNEG.F32 s4,s0                 ;235
                  |L1.276|
000114  eeb42a60          VCMP.F32 s4,s1                 ;235
000118  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;235
00011c  d04c              BEQ      |L1.440|
00011e  1c60              ADDS     r0,r4,#1              ;238
000120  ebac0700          SUB      r7,r12,r0             ;238
000124  e045              B        |L1.434|
                  |L1.294|
000126  fb02f004          MUL      r0,r2,r4              ;243
00012a  eb010580          ADD      r5,r1,r0,LSL #2       ;243
00012e  9801              LDR      r0,[sp,#4]            ;244
000130  4350              MULS     r0,r2,r0              ;244
000132  eb060080          ADD      r0,r6,r0,LSL #2       ;244
000136  9007              STR      r0,[sp,#0x1c]         ;244
000138  ed952a00          VLDR     s4,[r5,#0]            ;248
00013c  eeb52ac0          VCMPE.F32 s4,#0.0               ;248
000140  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;248
000144  dd02              BLE      |L1.332|
000146  ed952a00          VLDR     s4,[r5,#0]            ;248
00014a  e003              B        |L1.340|
                  |L1.332|
00014c  ed952a00          VLDR     s4,[r5,#0]            ;248
000150  eeb12a42          VNEG.F32 s4,s4                 ;248
                  |L1.340|
000154  eeb42a60          VCMP.F32 s4,s1                 ;248
000158  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;248
00015c  d125              BNE      |L1.426|
00015e  1b13              SUBS     r3,r2,r4              ;252
000160  e00a              B        |L1.376|
                  |L1.354|
000162  ed952a00          VLDR     s4,[r5,#0]            ;257
000166  eef01a42          VMOV.F32 s3,s4                 ;257
00016a  ed912a00          VLDR     s4,[r1,#0]            ;258
00016e  eca52a01          VSTM     r5!,{s4}              ;258
000172  ece11a01          VSTM     r1!,{s3}              ;259
000176  1e5b              SUBS     r3,r3,#1              ;262
                  |L1.376|
000178  2b00              CMP      r3,#0                 ;254
00017a  d1f2              BNE      |L1.354|
00017c  4613              MOV      r3,r2                 ;266
00017e  e00f              B        |L1.416|
                  |L1.384|
000180  9807              LDR      r0,[sp,#0x1c]         ;271
000182  ed902a00          VLDR     s4,[r0,#0]            ;271
000186  eef01a42          VMOV.F32 s3,s4                 ;271
00018a  ed962a00          VLDR     s4,[r6,#0]            ;272
00018e  9807              LDR      r0,[sp,#0x1c]         ;272
000190  ed802a00          VSTR     s4,[r0,#0]            ;272
000194  9807              LDR      r0,[sp,#0x1c]         ;272
000196  1d00              ADDS     r0,r0,#4              ;272
000198  9007              STR      r0,[sp,#0x1c]         ;272
00019a  ece61a01          VSTM     r6!,{s3}              ;273
00019e  1e5b              SUBS     r3,r3,#1              ;276
                  |L1.416|
0001a0  2b00              CMP      r3,#0                 ;268
0001a2  d1ed              BNE      |L1.384|
0001a4  2001              MOVS     r0,#1                 ;280
0001a6  9003              STR      r0,[sp,#0xc]          ;280
0001a8  e005              B        |L1.438|
                  |L1.426|
0001aa  9801              LDR      r0,[sp,#4]            ;287
0001ac  1c40              ADDS     r0,r0,#1              ;287
0001ae  9001              STR      r0,[sp,#4]            ;287
0001b0  1e7f              SUBS     r7,r7,#1              ;290
                  |L1.434|
0001b2  2f00              CMP      r7,#0                 ;240
0001b4  d1b7              BNE      |L1.294|
                  |L1.438|
0001b6  bf00              NOP                            ;283
                  |L1.440|
0001b8  9803              LDR      r0,[sp,#0xc]          ;295
0001ba  2801              CMP      r0,#1                 ;295
0001bc  d007              BEQ      |L1.462|
0001be  eeb50ac0          VCMPE.F32 s0,#0.0               ;295
0001c2  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;295
0001c6  d102              BNE      |L1.462|
0001c8  f06f0004          MVN      r0,#4                 ;297
0001cc  e792              B        |L1.244|
                  |L1.462|
0001ce  fb04f002          MUL      r0,r4,r2              ;301
0001d2  eb080b80          ADD      r11,r8,r0,LSL #2      ;301
0001d6  fb04f002          MUL      r0,r4,r2              ;302
0001da  eb0a0080          ADD      r0,r10,r0,LSL #2      ;302
0001de  9005              STR      r0,[sp,#0x14]         ;302
0001e0  4659              MOV      r1,r11                ;305
0001e2  9d05              LDR      r5,[sp,#0x14]         ;306
0001e4  ed9b2a00          VLDR     s4,[r11,#0]           ;309
0001e8  eeb00a42          VMOV.F32 s0,s4                 ;309
0001ec  1b13              SUBS     r3,r2,r4              ;313
0001ee  e008              B        |L1.514|
                  |L1.496|
0001f0  ed912a00          VLDR     s4,[r1,#0]            ;319
0001f4  eeb01a42          VMOV.F32 s2,s4                 ;319
0001f8  ee812a00          VDIV.F32 s4,s2,s0              ;320
0001fc  eca12a01          VSTM     r1!,{s4}              ;320
000200  1e5b              SUBS     r3,r3,#1              ;323
                  |L1.514|
000202  2b00              CMP      r3,#0                 ;315
000204  d1f4              BNE      |L1.496|
000206  4613              MOV      r3,r2                 ;327
000208  e008              B        |L1.540|
                  |L1.522|
00020a  ed952a00          VLDR     s4,[r5,#0]            ;333
00020e  eeb01a42          VMOV.F32 s2,s4                 ;333
000212  ee812a00          VDIV.F32 s4,s2,s0              ;334
000216  eca52a01          VSTM     r5!,{s4}              ;334
00021a  1e5b              SUBS     r3,r3,#1              ;337
                  |L1.540|
00021c  2b00              CMP      r3,#0                 ;329
00021e  d1f4              BNE      |L1.522|
000220  4641              MOV      r1,r8                 ;344
000222  4655              MOV      r5,r10                ;345
000224  2700              MOVS     r7,#0                 ;348
000226  f8cdc004          STR      r12,[sp,#4]           ;352
00022a  e03b              B        |L1.676|
                  |L1.556|
00022c  42a7              CMP      r7,r4                 ;357
00022e  d105              BNE      |L1.572|
000230  1b10              SUBS     r0,r2,r4              ;361
000232  eb010180          ADD      r1,r1,r0,LSL #2       ;361
000236  eb050582          ADD      r5,r5,r2,LSL #2       ;363
00023a  e02d              B        |L1.664|
                  |L1.572|
00023c  ed912a00          VLDR     s4,[r1,#0]            ;368
000240  eeb00a42          VMOV.F32 s0,s4                 ;368
000244  f8cdb018          STR      r11,[sp,#0x18]        ;371
000248  9805              LDR      r0,[sp,#0x14]         ;372
00024a  9004              STR      r0,[sp,#0x10]         ;372
00024c  1b13              SUBS     r3,r2,r4              ;376
00024e  e00e              B        |L1.622|
                  |L1.592|
000250  ed912a00          VLDR     s4,[r1,#0]            ;382
000254  eeb01a42          VMOV.F32 s2,s4                 ;382
000258  9806              LDR      r0,[sp,#0x18]         ;383
00025a  ecf02a01          VLDM     r0!,{s5}              ;383
00025e  eeb02a41          VMOV.F32 s4,s2                 ;383
000262  ee002a62          VMLS.F32 s4,s0,s5              ;383
000266  9006              STR      r0,[sp,#0x18]         ;383
000268  eca12a01          VSTM     r1!,{s4}              ;383
00026c  1e5b              SUBS     r3,r3,#1              ;386
                  |L1.622|
00026e  2b00              CMP      r3,#0                 ;378
000270  d1ee              BNE      |L1.592|
000272  4613              MOV      r3,r2                 ;391
000274  e00e              B        |L1.660|
                  |L1.630|
000276  ed952a00          VLDR     s4,[r5,#0]            ;397
00027a  eeb01a42          VMOV.F32 s2,s4                 ;397
00027e  9804              LDR      r0,[sp,#0x10]         ;398
000280  ecf02a01          VLDM     r0!,{s5}              ;398
000284  eeb02a41          VMOV.F32 s4,s2                 ;398
000288  ee002a62          VMLS.F32 s4,s0,s5              ;398
00028c  9004              STR      r0,[sp,#0x10]         ;398
00028e  eca52a01          VSTM     r5!,{s4}              ;398
000292  1e5b              SUBS     r3,r3,#1              ;401
                  |L1.660|
000294  2b00              CMP      r3,#0                 ;393
000296  d1ee              BNE      |L1.630|
                  |L1.664|
000298  eb010184          ADD      r1,r1,r4,LSL #2       ;407
00029c  9801              LDR      r0,[sp,#4]            ;410
00029e  1e40              SUBS     r0,r0,#1              ;410
0002a0  9001              STR      r0,[sp,#4]            ;410
0002a2  1c7f              ADDS     r7,r7,#1              ;413
                  |L1.676|
0002a4  9801              LDR      r0,[sp,#4]            ;354
0002a6  2800              CMP      r0,#0                 ;354
0002a8  d1c0              BNE      |L1.556|
0002aa  f1080804          ADD      r8,r8,#4              ;417
0002ae  9802              LDR      r0,[sp,#8]            ;420
0002b0  1e40              SUBS     r0,r0,#1              ;420
0002b2  9002              STR      r0,[sp,#8]            ;420
0002b4  1c64              ADDS     r4,r4,#1              ;423
                  |L1.694|
0002b6  9802              LDR      r0,[sp,#8]            ;196
0002b8  2800              CMP      r0,#0                 ;196
0002ba  f47faed7          BNE      |L1.108|
0002be  9000              STR      r0,[sp,#0]            ;682
0002c0  9803              LDR      r0,[sp,#0xc]          ;684
0002c2  2801              CMP      r0,#1                 ;684
0002c4  d01f              BEQ      |L1.774|
0002c6  eeb50ac0          VCMPE.F32 s0,#0.0               ;684
0002ca  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;684
0002ce  d11a              BNE      |L1.774|
0002d0  f8d98004          LDR      r8,[r9,#4]            ;686
0002d4  2700              MOVS     r7,#0                 ;687
0002d6  e00a              B        |L1.750|
                  |L1.728|
0002d8  eb080087          ADD      r0,r8,r7,LSL #2       ;689
0002dc  ed902a00          VLDR     s4,[r0,#0]            ;689
0002e0  eeb52ac0          VCMPE.F32 s4,#0.0               ;689
0002e4  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;689
0002e8  d000              BEQ      |L1.748|
0002ea  e004              B        |L1.758|
                  |L1.748|
0002ec  1c7f              ADDS     r7,r7,#1              ;687
                  |L1.750|
0002ee  fb0cf002          MUL      r0,r12,r2             ;687
0002f2  42b8              CMP      r0,r7                 ;687
0002f4  d8f0              BHI      |L1.728|
                  |L1.758|
0002f6  bf00              NOP                            ;690
0002f8  fb0cf002          MUL      r0,r12,r2             ;693
0002fc  42b8              CMP      r0,r7                 ;693
0002fe  d102              BNE      |L1.774|
000300  f06f0004          MVN      r0,#4                 ;694
000304  9000              STR      r0,[sp,#0]            ;694
                  |L1.774|
000306  9800              LDR      r0,[sp,#0]            ;698
000308  e6f4              B        |L1.244|
;;;700    
                          ENDP

00030a  0000              DCW      0x0000
                  |L1.780|
00030c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\stm32LIB\\Device\\arm_mat_inverse_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____REV16|
#line 388 "..\\stm32LIB\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____REVSH|
#line 402
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____RRX|
#line 587
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
