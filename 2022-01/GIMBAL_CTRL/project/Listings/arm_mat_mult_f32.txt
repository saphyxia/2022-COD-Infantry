; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\objects\arm_mat_mult_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O0 --diag_suppress=9931 -I..\stm32LIB\inc -I..\stm32LIB\CMSIS\Include -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM4F -I..\user\_Dsp\Include -I..\user\_Algorithms -I..\user\_Bsp -I..\user\_Device -I..\user\_Task -I..\system -I..\stm32LIB\CMSIS -I..\system -I..\FreeRTOS -I..\user -I.\RTE\_COD_Gimbal_Task -IC:\keil_v5_project\Keil\STM32F4xx_DFP\2.9.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=528 -DSTM32F407xx -DSTM32F40_41xxx -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM4 -D__FPU_PRESENT --omf_browse=.\objects\arm_mat_mult_f32.crf ..\stm32LIB\Device\arm_mat_mult_f32.c]
                          THUMB

                          AREA ||i.arm_mat_mult_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_f32 PROC
;;;77     
;;;78     arm_status arm_mat_mult_f32(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;79       const arm_matrix_instance_f32 * pSrcA,
;;;80       const arm_matrix_instance_f32 * pSrcB,
;;;81       arm_matrix_instance_f32 * pDst)
;;;82     {
000004  b083              SUB      sp,sp,#0xc
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;83       float32_t *pIn1 = pSrcA->pData;                /* input data matrix pointer A */
00000a  6862              LDR      r2,[r4,#4]
;;;84       float32_t *pIn2 = pSrcB->pData;                /* input data matrix pointer B */
00000c  6869              LDR      r1,[r5,#4]
;;;85       float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A  */
00000e  f8d4c004          LDR      r12,[r4,#4]
;;;86       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
000012  9805              LDR      r0,[sp,#0x14]
000014  6840              LDR      r0,[r0,#4]
000016  9002              STR      r0,[sp,#8]
;;;87       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;88       float32_t sum;                                 /* Accumulator */
;;;89       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
000018  8820              LDRH     r0,[r4,#0]
00001a  9001              STR      r0,[sp,#4]
;;;90       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
00001c  886b              LDRH     r3,[r5,#2]
;;;91       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
00001e  8867              LDRH     r7,[r4,#2]
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       float32_t in1, in2, in3, in4;
;;;98       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000020  f04f0a00          MOV      r10,#0
000024  f8dde004          LDR      lr,[sp,#4]
;;;99       arm_status status;                             /* status of matrix multiplication */
;;;100    
;;;101    #ifdef ARM_MATH_MATRIX_CHECK
;;;102    
;;;103    
;;;104      /* Check for matrix mismatch condition */
;;;105      if((pSrcA->numCols != pSrcB->numRows) ||
;;;106         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;107      {
;;;108    
;;;109        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;110        status = ARM_MATH_SIZE_MISMATCH;
;;;111      }
;;;112      else
;;;113    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;114    
;;;115      {
;;;116        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;117        /* row loop */
;;;118        do
000028  bf00              NOP      
                  |L1.42|
;;;119        {
;;;120          /* Output pointer is set to starting address of the row being processed */
;;;121          px = pOut + i;
00002a  9802              LDR      r0,[sp,#8]
00002c  eb00088a          ADD      r8,r0,r10,LSL #2
;;;122    
;;;123          /* For every row wise process, the column loop counter is to be initiated */
;;;124          col = numColsB;
000030  4699              MOV      r9,r3
;;;125    
;;;126          /* For every row wise process, the pIn2 pointer is set    
;;;127           ** to the starting address of the pSrcB data */
;;;128          pIn2 = pSrcB->pData;
000032  6869              LDR      r1,[r5,#4]
;;;129    
;;;130          j = 0u;
000034  f04f0b00          MOV      r11,#0
;;;131    
;;;132          /* column loop */
;;;133          do
000038  bf00              NOP      
                  |L1.58|
;;;134          {
;;;135            /* Set the variable sum, that acts as accumulator, to zero */
;;;136            sum = 0.0f;
00003a  eddf2a41          VLDR     s5,|L1.320|
00003e  eeb00a62          VMOV.F32 s0,s5
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;139            pIn1 = pInA;
000042  4662              MOV      r2,r12
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2u;
000044  10be              ASRS     r6,r7,#2
;;;143    
;;;144            /* matrix multiplication        */
;;;145            while(colCnt > 0u)
000046  e042              B        |L1.206|
                  |L1.72|
;;;146            {
;;;147              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;148              in3 = *pIn2;
000048  edd12a00          VLDR     s5,[r1,#0]
00004c  eef01a62          VMOV.F32 s3,s5
;;;149              pIn2 += numColsB;
000050  eb010183          ADD      r1,r1,r3,LSL #2
;;;150              in1 = pIn1[0];
000054  edd22a00          VLDR     s5,[r2,#0]
000058  eef00a62          VMOV.F32 s1,s5
;;;151              in2 = pIn1[1];
00005c  edd22a01          VLDR     s5,[r2,#4]
000060  eeb01a62          VMOV.F32 s2,s5
;;;152              sum += in1 * in3;
000064  eef02a40          VMOV.F32 s5,s0
000068  ee402aa1          VMLA.F32 s5,s1,s3
00006c  eeb00a62          VMOV.F32 s0,s5
;;;153              in4 = *pIn2;
000070  edd12a00          VLDR     s5,[r1,#0]
000074  eeb02a62          VMOV.F32 s4,s5
;;;154              pIn2 += numColsB;
000078  eb010183          ADD      r1,r1,r3,LSL #2
;;;155              sum += in2 * in4;
00007c  eef02a40          VMOV.F32 s5,s0
000080  ee412a02          VMLA.F32 s5,s2,s4
000084  eeb00a62          VMOV.F32 s0,s5
;;;156    
;;;157              in3 = *pIn2;
000088  edd12a00          VLDR     s5,[r1,#0]
00008c  eef01a62          VMOV.F32 s3,s5
;;;158              pIn2 += numColsB;
000090  eb010183          ADD      r1,r1,r3,LSL #2
;;;159              in1 = pIn1[2];
000094  edd22a02          VLDR     s5,[r2,#8]
000098  eef00a62          VMOV.F32 s1,s5
;;;160              in2 = pIn1[3];
00009c  edd22a03          VLDR     s5,[r2,#0xc]
0000a0  eeb01a62          VMOV.F32 s2,s5
;;;161              sum += in1 * in3;
0000a4  eef02a40          VMOV.F32 s5,s0
0000a8  ee402aa1          VMLA.F32 s5,s1,s3
0000ac  eeb00a62          VMOV.F32 s0,s5
;;;162              in4 = *pIn2;
0000b0  edd12a00          VLDR     s5,[r1,#0]
0000b4  eeb02a62          VMOV.F32 s4,s5
;;;163              pIn2 += numColsB;
0000b8  eb010183          ADD      r1,r1,r3,LSL #2
;;;164              sum += in2 * in4;
0000bc  eef02a40          VMOV.F32 s5,s0
0000c0  ee412a02          VMLA.F32 s5,s2,s4
0000c4  eeb00a62          VMOV.F32 s0,s5
;;;165              pIn1 += 4u;
0000c8  3210              ADDS     r2,r2,#0x10
;;;166    
;;;167              /* Decrement the loop count */
;;;168              colCnt--;
0000ca  1e70              SUBS     r0,r6,#1
0000cc  b286              UXTH     r6,r0
                  |L1.206|
0000ce  2e00              CMP      r6,#0                 ;145
0000d0  d1ba              BNE      |L1.72|
;;;169            }
;;;170    
;;;171            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.    
;;;172             ** No loop unrolling is used. */
;;;173            colCnt = numColsA % 0x4u;
0000d2  f0070603          AND      r6,r7,#3
;;;174    
;;;175            while(colCnt > 0u)
0000d6  e00d              B        |L1.244|
                  |L1.216|
;;;176            {
;;;177              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;178              sum += *pIn1++ * (*pIn2);
0000d8  ecb23a01          VLDM     r2!,{s6}
0000dc  edd13a00          VLDR     s7,[r1,#0]
0000e0  eef02a40          VMOV.F32 s5,s0
0000e4  ee432a23          VMLA.F32 s5,s6,s7
0000e8  eeb00a62          VMOV.F32 s0,s5
;;;179              pIn2 += numColsB;
0000ec  eb010183          ADD      r1,r1,r3,LSL #2
;;;180    
;;;181              /* Decrement the loop counter */
;;;182              colCnt--;
0000f0  1e70              SUBS     r0,r6,#1
0000f2  b286              UXTH     r6,r0
                  |L1.244|
0000f4  2e00              CMP      r6,#0                 ;175
0000f6  d1ef              BNE      |L1.216|
;;;183            }
;;;184    
;;;185            /* Store the result in the destination buffer */
;;;186            *px++ = sum;
0000f8  eca80a01          VSTM     r8!,{s0}
;;;187    
;;;188            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;189            j++;
0000fc  f10b0001          ADD      r0,r11,#1
000100  fa1ffb80          UXTH     r11,r0
;;;190            pIn2 = pSrcB->pData + j;
000104  6868              LDR      r0,[r5,#4]
000106  eb00018b          ADD      r1,r0,r11,LSL #2
;;;191    
;;;192            /* Decrement the column loop counter */
;;;193            col--;
00010a  f1a90001          SUB      r0,r9,#1
00010e  fa1ff980          UXTH     r9,r0
;;;194    
;;;195          } while(col > 0u);
000112  f1b90f00          CMP      r9,#0
000116  d190              BNE      |L1.58|
;;;196    
;;;197    #else
;;;198    
;;;199      /* Run the below code for Cortex-M0 */
;;;200    
;;;201      float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
;;;202      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;203      arm_status status;                             /* status of matrix multiplication */
;;;204    
;;;205    #ifdef ARM_MATH_MATRIX_CHECK
;;;206    
;;;207      /* Check for matrix mismatch condition */
;;;208      if((pSrcA->numCols != pSrcB->numRows) ||
;;;209         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;210      {
;;;211    
;;;212        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;213        status = ARM_MATH_SIZE_MISMATCH;
;;;214      }
;;;215      else
;;;216    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;217    
;;;218      {
;;;219        /* The following loop performs the dot-product of each row in pInA with each column in pInB */
;;;220        /* row loop */
;;;221        do
;;;222        {
;;;223          /* Output pointer is set to starting address of the row being processed */
;;;224          px = pOut + i;
;;;225    
;;;226          /* For every row wise process, the column loop counter is to be initiated */
;;;227          col = numColsB;
;;;228    
;;;229          /* For every row wise process, the pIn2 pointer is set     
;;;230           ** to the starting address of the pSrcB data */
;;;231          pIn2 = pSrcB->pData;
;;;232    
;;;233          /* column loop */
;;;234          do
;;;235          {
;;;236            /* Set the variable sum, that acts as accumulator, to zero */
;;;237            sum = 0.0f;
;;;238    
;;;239            /* Initialize the pointer pIn1 to point to the starting address of the row being processed */
;;;240            pIn1 = pInA;
;;;241    
;;;242            /* Matrix A columns number of MAC operations are to be performed */
;;;243            colCnt = numColsA;
;;;244    
;;;245            while(colCnt > 0u)
;;;246            {
;;;247              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;248              sum += *pIn1++ * (*pIn2);
;;;249              pIn2 += numColsB;
;;;250    
;;;251              /* Decrement the loop counter */
;;;252              colCnt--;
;;;253            }
;;;254    
;;;255            /* Store the result in the destination buffer */
;;;256            *px++ = sum;
;;;257    
;;;258            /* Decrement the column loop counter */
;;;259            col--;
;;;260    
;;;261            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;262            pIn2 = pInB + (numColsB - col);
;;;263    
;;;264          } while(col > 0u);
;;;265    
;;;266    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;267    
;;;268          /* Update the pointer pInA to point to the  starting address of the next row */
;;;269          i = i + numColsB;
000118  eb0a0003          ADD      r0,r10,r3
00011c  fa1ffa80          UXTH     r10,r0
;;;270          pInA = pInA + numColsA;
000120  eb0c0c87          ADD      r12,r12,r7,LSL #2
;;;271    
;;;272          /* Decrement the row loop counter */
;;;273          row--;
000124  f1ae0001          SUB      r0,lr,#1
000128  fa1ffe80          UXTH     lr,r0
;;;274    
;;;275        } while(row > 0u);
00012c  f1be0f00          CMP      lr,#0
000130  f47faf7b          BNE      |L1.42|
;;;276        /* Set status as ARM_MATH_SUCCESS */
;;;277        status = ARM_MATH_SUCCESS;
000134  2000              MOVS     r0,#0
000136  9000              STR      r0,[sp,#0]
;;;278      }
;;;279    
;;;280      /* Return to application */
;;;281      return (status);
000138  9800              LDR      r0,[sp,#0]
;;;282    }
00013a  b006              ADD      sp,sp,#0x18
00013c  e8bd8ff0          POP      {r4-r11,pc}
;;;283    
                          ENDP

                  |L1.320|
000140  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "..\\stm32LIB\\Device\\arm_mat_mult_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____REV16|
#line 388 "..\\stm32LIB\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___18_arm_mat_mult_f32_c_d029f10d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____REVSH|
#line 402
|__asm___18_arm_mat_mult_f32_c_d029f10d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____RRX|
#line 587
|__asm___18_arm_mat_mult_f32_c_d029f10d____RRX| PROC
#line 588

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
